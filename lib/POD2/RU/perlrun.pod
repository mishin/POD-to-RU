=encoding utf8

=head1 НАИМЕНОВАНИЕ

perlrun - как запускать интерпретатор Perl

=head1 СИНТАКСИС

B<perl>	S<[ B<-sTtuUWX> ]>
	S<[ B<-hv> ] [ B<-V>[:I<configvar>] ]>
	S<[ B<-cw> ] [ B<-d>[B<t>][:I<отладчик>] ] [ B<-D>[I<кол-во/список>] ]>
	S<[ B<-pna> ] [ B<-F>I<шаблон> ] [ B<-l>[I<восьмеричный>] ] [ B<-0>[I<восьмеричный/шестнадцатеричный>] ]>
	S<[ B<-I>I<dir> ] [ B<-m>[B<->]I<модуль> ] [ B<-M>[B<->]I<'модуль...'> ] [ B<-f> ]>
	S<[ B<-C [I<кол-во/список>] >]>
	S<[ B<-S> ]>
	S<[ B<-x>[I<dir>] ]>
	S<[ B<-i>[I<расширение>] ]>
	S<[ [B<-e>|B<-E>] I<'команда'> ] [ B<--> ] [ I<файл программы> ] [ I<аргумент> ]...>

=head1 ОПИСАНИЕ

Стандартный путь запуска Perl программы может быть таким: или сделать файл исполняемым, либо, передать имя исходного файла в качестве аргумента командной строкb.  (Интерактивная среда Perl также возможна - см. L<perldebug> для деталей о том, как это сделать) После запуска Perl ищет вашу программу в одном из следующих мест:

=over 4

=item 1.

Выполняется строка (однострочник), если в командной строке указаны параметры B<-e> или B<-E>.

=item 2.

Сценарий находится в файле, указанном в первом имени файла в командной строке.
(Заметим, что системы, поддерживающие нотацию C<#!> вызывают интерпретатор, используя путь, стоящий за  C<#!>. См. L<Расположение Perl>.)

=item 3.

Принятый в неявно через стандартный ввод.  Это работает только тогда, когда в качестве аргумента нет имени файла - для передачи аргументов на STDIN (стандартный ввод/input) чтения программы необходимо явно указать "-" для имени программы.

=back

В методах 2 и 3, Perl начинает анализировать входной файла с самого начала, если вы не указали опцию B<-x>, и в этом случае производится проверка первой строки, которая начинается с C<#!> и содержит слово " Perl ", и начинает там вместо этого.  Это полезно для запуска программы включенной в большое сообщение.  (В этом случае вы можете обозначить конец программы с помощью маркера C<__END__> .)

Строка C<#!> всегда рассматривается для поиска переключателей, как строка, которая в настоящее время анализируется.  Таким образом, если вы на машине, которая позволяет только один аргумент на строке C<#!>, или еще хуже, даже не признает C<#!> линии, вы все равно можете получить согласованное поведение переключателя независимо от того, как Perl был вызван, даже если  B<-x> был использован, чтобы найти начало программы.

Потому что исторически некоторые операционные системы молча отрубили в ядре интерпретацию C<#!> строки после 32 символов, некоторые переключатели могут быть переданы в командной строке, а некоторые не могут, вы могли бы даже получить "-" без этого письма, если вы не будете осторожны.
Вы, наверное, хотите, чтобы убедиться, что все ваши переключатели действуют до или после 32-символьной границы.  Большинство переключатели на самом деле не волнует, если они обработаны избыточно, но получение "-" вместо полных опций, может  привести к тому, что Perl будет попытаться выполнить скрипт со стандартного ввода, а не из вашей программы.  И частичный ключ B<-I> мог также вызвать странные результаты.

Некоторым ключам не все равно будут ли они обрабатываться дважды, например комбинации  B<-l> и B<-0>.  Либо поставить все переключатели после 32-символьной границы (если применимо), или замените использование B<-0>I<digits> на C<BEGIN{ $/ = "\0digits"; }>.

Разбор опции C<#!> начинается там, где в строку входит слово "Perl".
Последовательности "-*" и "- " специально игнорируются, чтобы вы могли их использовать, если вам это нужно, скажем

    #!/bin/sh
    #! -*-perl-*-
    eval 'exec perl -x -wS $0 ${1+"$@"}'
        if 0;

позволяя Perl увидеть ключ B<-p>.

Аналогичный трюк предполагает использование программы I<env> , если она у вас есть.

    #!/usr/bin/env perl

Приведенные выше примеры по использованию относительного пути к интерпретатору Perl, находят Perl в независимости от версии программы, которая встречается первой в пользовательских путях.  Если вы хотите конкретной версии Perl, скажем, perl5.14.1, вы должны поместить это прямо в путь на строке C<#!>.

Если строка C<#!> не содержит слово "perl", ни слово "indir" программа, написанная послеC<#!> будет выполняться вместо интерпретатора Perl.  Это немного странно, но это помогает людям на машинах, у которых нет C<#!>, потому что они могут сказать, что их программа SHELL есть F</usr/bin/perl> И Perl затем отправляет программу для корректной обработки интерпретатором.

После размещения вашей программы, Perl компилирует внешнюю (по отношению к Perl) программу во внутреннюю форму.  Если есть какие-либо ошибки компиляции, программы не пытается выполниться.  (Это не похоже на типичный сценарий оболочки, который может выполнить часть сценария, прежде чем найдет синтаксические ошибки.)

Если программа синтаксически правильна, она выполняется.  Если программа работает до конца, не вызвая операторы exit() или die(), неявный C<exit(0)> предусмотрен для указания успешного завершения.

=head2 #! и ссылка на не-Unix системах X<hashbang> X<#!>

Юниксовая C<#!> техника может быть смоделирована на других системах:

=over 4

=item OS/2

Устанавливает

    extproc perl -S -your_switches

в качестве первой линии в C<*.cmd> файле (B<-S> в связи с ошибкой в ​​cmd.exe по регуляции `extproc').

=item MS-DOS

Создайте пакетный файл для запуска вашей программы, и кодифицируйте его в C<ALTERNATE_SHEBANG> (См. F<dosish.h> в файле в дистрибутива для получения дополнительной информации).

=item Win95/NT

Win95/NT установки, когда используется ActiveState Perl установщик он изменяет реестр, чтобы связать расширение F<.pl>  с интерпретатором Perl.  Если вы установили Perl с помощью других средств (в том числе билд из источников), возможно, придется внести изменения в реестр самостоятельно.  Заметим, что это означает, что вы больше не можете отличить исполняемые программы Perl и Perl файл библиотеки.

=item VMS

Устанавливает

 $ perl -mysw 'f$env("procedure")' 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' !
 $ exit++ + ++$status != 0 and $exit = $status = undef;

в верхней части вашей программы, где B<-mysw> любые параметры командной строки, которые вы хотите передать Perl.  Теперь вы можете вызвать программу непосредственно, говоря C<perl program> Или в виде DCL (Digital Command Language цифровой командный язык) процедуры, говоря, C<@program> (или косвенно через F<DCL$PATH> только с помощью название программы).

Это заклинание достаточно трудно вспомнить, но Perl отобразит его для вас, если вы говорите,  C<perl "-V:startperl">.

=back

Командный интерпретаторы на не-Unix системах имеют отличные  представления о том, как делать кавычки, чем в Unix shells.  Вам нужно будет узнать специальные символы при запуске интерпретатора из командной строки (C<*>, C<\> and C<"> являются общими) и как защитить пробелы и эти символы для запуска однострочников (см.  L<-e|/-e commandline> ниже).

На некоторых системах, вы, возможно, придется изменить одинарные кавычки на двойные, то, что вы I<не> должны делать на Unix или Plan 9 системах.  Вы можете также изменить одну % на a %%.

Например:

    # Unix
    perl -e 'print "Hello world\n"'

    # MS-DOS, etc.
    perl -e "print \"Hello world\n\""

    # VMS
    perl -e "print ""Hello world\n"""

Проблема в том, что ничто из этого не является надежным: он зависит от команды, и вполне возможно не будет работать.  Если в I<4DOS> была командная оболочка, это, вероятно работает лучше:

    perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

B<CMD.EXE> в Windows NT поскользнулся на многой стандартной функциональности Unix, когда никто не смотрел, но попробуйте найти документацию на ее правила экранирования.

Здесь нет общего решения на все это.  Это просто беспорядок.

=head2 Расположение Perl
X<perl, location of interpreter>

Это может показаться очевидным сказать, но Perl полезен только тогда, когда пользователи могут легко найти его.  Когда это возможно, это хорошо как для F</usr/bin/perl> и F</usr/local/bin/perl> быть символическими ссылками на фактические двоичные файлы.  Если это не может быть сделано, системным администраторам настоятельно рекомендуется поставить (символические ссылки) на Perl и сопутствующие утилиты в каталог, который обычно встречаются  в пользовательском PATH (пути), или в некоторых других очевидных и удобных местах.

В этой документации, C<#!/usr/bin/perl> на первой строке программы будет стоять какой бы метод не работал в вашей системе.  Вам рекомендуется использовать определенный путь, если вы заботитесь о конкретной версии интерпретатора Perl.

    #!/usr/local/bin/perl5.14

или если вы просто хотите запустить на минимальной версии, разместить подобное заявление в верхней части вашей программы:

    use 5.014;

=head2 Опции команды
X<perl, command switches> X<command switches>

Как и во всех стандартных командах, односимвольный переключатель может быть положен в кластер со следующимо переключателем, если таковые имеются.

    #!/usr/bin/perl -spi.orig	# то же самое -s -p -i.orig

Переключатели (опции Switches) включают в себя:

=over 5

=item B<-0>[I<восьмеричный/шестнадцатеричный>]
X<-0> X<$/>

указывается разделитель входных записей ((C<$/>) как восьмеричное или шестнадцатеричное число.  Если нет никаких цифр, нулевой символ является разделителем.  Другие переключатели могут предшествовать или следовать за цифрами.  Например, если у вас есть версии I<find> , которая может печатать имена файлов, завершающихся нулевым символом, то можно сказать следующее:

    find . -name '*.orig' -print0 | perl -n0e unlink

Специальное значение 00 приводят Perl захватывать файлы по параграфам (slurp files in paragraph mode).
Любое значение 0400 или выше, будет вызывать Perl захватывать файлы целиком, но по соглашению значение 0777 является тем, которое обычно используется для этой цели.

Вы также можете указать символ-разделитель с помощью шестнадцатеричного формата: B<-0xI<HHH...>>, Где C<I<H>> действительные шестнадцатеричные цифры.  В отличие от восьмеричной формы, это может быть использовано для указания любого символ в Юникоде, даже тех, которые идут за 0xFF.  Так что, если вы мне  I<на самом> деле хотите разделитель записи 0777, указажите его как B<-0x1FF>.  (Это означает, что вы не можете использовать опцию B<-x> с именем каталога, который состоит из шестнадцатеричных цифр, иначе Perl подумает, что вы указали шестнадцатеричное число B<-0>.)

=item B<-a>
X<-a> X<autosplit>

включает AutoSplit режим (режим авторазбиения), когда используется B<-n> или B<-p>.  Неявная команда разбиения в массив @F делается, как первая вещь внутри неявного цикла, который создается, если указаны опции B<-n> или B<-p>.

    perl -ane 'print pop(@F), "\n";'

эквивалентна

    while (<>) {
	@F = split(' ');
	print pop(@F), "\n";
    }

Альтернативные разделители могут быть заданы с помощью B<-F>.

=item B<-C [I<number/list>]>
X<-C>

Флаг B<-C> указывает на некоторые из функций Perl Unicode.

По состоянию на 5.8.1,  B<-C> может следовать либо номер или список параметров, букв.  Буквы, их числовые значения и эффекты являются следующие перечисление букв равно суммированию чисел.

    I     1   STDIN считается в UTF-8
    O     2   STDOUT будет в UTF-8
    E     4   STDERR будет в UTF-8
    S     7   I + O + E
    i     8   UTF-8 представляет собой слой умолчанию PerlIO для потоков ввода
    o    16   UTF-8 представляет собой слой PerlIO умолчанию для потоков вывода
    D    24   i + o
    A    32    элементы @ARGV ожидаются, как закодированные строки
              в UTF-8
    L    64   обычно "IOEioA" являются безусловными, L являются безусловными (normally the "IOEioA" are unconditional, the L makes)
              они зависят от локальных переменных среды
              (LC_ALL, LC_TYPE, и LANG, в следующем порядке
              убывания приоритета) - если переменные указывают
              UTF-8, потом выбирается "IOEioA" в действительности (UTF-8, then the selected "IOEioA" are in effect)
    a   256   Установите ${^UTF8CACHE} в -1, для запуска UTF-8 кэширования
              код в режиме отладки.

=для документирования_поддокументов (documenting_the_underdocumented)
perl.h gives W/128 as PERL_UNICODE_WIDESYSCALLS "/* for Sarathy */"

=для будущего (todo)
perltodo упоминает Unicode в %ENV и именах файлов. Я думаю, что это будут варианты e и f (или F).

Например, B<-COE> и B<-C6> будут оба переключать UTF-8 режим на обоих STDOUT и STDERR.  Повторение букв избыточно, не суммируются, не переключения.

Опция C<io> означает, что любой последующий open() (или аналогичная операция ввода/вывода) в текущей области файла будет иметь C<:utf8> PerlIO слой неявно применяется к ним, другими словами, UTF-8, как ожидается, из любого входного потока и UTF-8 производится в любой выходной поток.  Это просто по умолчанию, с явными слоями (explicit layers) в open() и с binmode () можно управлять потоками, как обычно.

B<-C> сама по себе (не следует любое число или список опций), или пустая строка C<""> для C<PERL_UNICODE> переменной окружения, имеет тот же эффект, как B<-CSDL>.  Другими словами, стандарт ввода/вывода управляет умолчанием C<open()> слоя и будет переведет в UTF-8 I<но> только если переменные окружения указывают на локаль(locale) UTF-8.  Такое поведение следует I<неясно> (и проблематично) UTF-8 поведение Perl 5.8.0.
((См. L<perl581delta/UTF-8 больше не является поведением по умолчанию под локалями UTF-8>.)

Вы можете использовать B<-C0> (или C<"0"> для C<PERL_UNICODE>, чтобы явно отключить все выше Unicode особенности (features).

Волшебная переменная только для чтения C<${^UNICODE}> отражает числовое значение данного параметра.  Эта переменная устанавливается во время запуска Perl и после этого она доступна только  для чтения.  Если вы хотите эффекта во время выполнения (runtime effects), используйте трёхаргументный open() (see L<perlfunc/open>), двухаргументный binmode () (см. L<perlfunc/binmode> ) И прагму (pragma) C<open>  (см. L<open>).

(В Perl раньше, чем 5.8.1 B<-C> переключатель был только Win32-переключатель, который включен использование юникодовых "широкий системный вызов" Win32 API.
Эта функция практически не используется, однако, и параметр командной строки, поэтому был "отправлен в ведро" ( "recycled").)

B <Note:> Начинаяс perl 5.10.1, если опция B<-C> используется на строке C<#!>, то он должен быть указан в командной строке, а, так как стандартные потоки уже настроены в этот момент исполнения интерпретатора Perl.
Вы также можете использовать binmode(), чтобы установить кодировку потока ввода/вывода.

=item B<-c>
X<-c>

вызывает Perl для проверки синтаксиса программы и последующего выхода без выполнения.  На самом деле, эта опция I<будет> выполнять и C<BEGIN>, C<UNITCHECK> или С<CHECK> блоки и любые C<use> объявления: они рассматриваются как происходящие за пределами выполнения вашей программы.  C<INIT> и C<END> блоки, однаку, будут пропущены.

=item B<-d>
X<-d> X<-dt>

=item B<-dt>

запускает программу под управлением отладчика Perl.  См. L<perldebug>.
Если B<t> указан, то он указывает отладчику, что поток(threads)  будет использоваться в коде, который отлаживается.

=item B<-d:>I<MOD[=bar,baz]>
X<-d> X<-dt>

=item B<-dt:>I<MOD[=bar,baz]>

запускает программу под контроль отладки, профилирования, или отслеживание модуля, устанавливаемого как C<Devel::I<MOD>>. Например, B<-d:DProf> выполняет программу, используя C<Devel::DProf> профайлер (profiler).  Как и в случае B<-M> флага, параметры могут быть переданы пакету C<Devel::I<MOD>>, в котором они будут получены и интерпретированы с помощью процедуры C<Devel::I<MOD>::import>.  Опять же, как B<-M>,
используйте -B<-d:-I<MOD>> для вызова C<Devel::I<MOD>::unimport> вместо импорта.  Разделенный запятыми список опций должен следовать за символом C<=>.  Если B<t> указан, то он указывает, что отладчик темы будет использоваться в коде отладки.  См. L<perldebug>.

=item B<-D>I<letters>
X<-D> X<DEBUGGING> X<-DDEBUGGING>

=item B<-D>I<number>

устанавливает флаги отладки.  Чтобы посмотреть, как он выполняет свою программу, используйте B<-Dtls>.  (Это работает только тогда, когда отладка скомпилирована в Perl.) Еще одно приятное значение B<-Dx>, в котором перечислены списки вышего скомпилированного синтаксического дерева.  И B<-Dr> отображает скомпилированные регулярные выражения; формат вывода объясняется в L<perldebguts> .

В качестве альтернативы указажите число вместо списка букв (например, B<-D14> эквивалентен B<-Dtls>)

        1  p  Разбор на токены или слова и парсинг (Tokenizing and parsing) (с v, отображает стек разборk)
        2  s  Снимок (snapshots) стека (с v, отображает все стеки)
        4  l  Контекст (цикла) стек обработки
        8  t  Трассирует выполнение
       16  o  Метод и разрешения перегрузки
       32  c  Строковые/числовые преобразования
       64  P  Печатает профилирующую информацию, исходный файл входного состояния 
      128  m  Память и распределение SV (Scalar Value) скалярных переменных
      256  f  Формат обработки
      512  r  Разбор регулярных выражений и их исполнение
     1024  x  Дамп синтаксического дерева (Syntax tree dump)
     2048  u  Проверки на разрушение 
     4096  U  Неофициальный, Пользовательский хак (hacking)(зарезервирован для частного,
              неизданного использования)
     8192  H  Хэш дамп (Hash dump) -- узурпирует/захватывает (usurps) values()
    16384  X  Блокнот распределения (Scratchpad allocation)
    32768  D  Очистка (Cleaning up)
    65536  S  Распределение оперативной памяти (Op slab allocation http://ru.wikipedia.org/wiki/Slab)
   131072  T  Разделение на слова/токены (Tokenizing)
   262144  R  Включая счетчики ссылок дампинговых переменных (например, при
              использование -Ds)
   524288  J  показывает s,t,P-отладка (не выпрыгивать выше) на коды операций в оперативной памяти (show s,t,P-debug (don't Jump over) on opcodes withi)
              package DB
  1048576  v  Verbose (многословный): использовать в сочетании с другими флагами
  2097152  C  Копирование при записи (Copy On Write)
  4194304  A  Проверка согласованности внутренних структур
  8388608  q  quiet - в настоящее время только подавляет "Запуск" ("EXECUTING")
              message
 16777216  M  отслеживает умное сопоставление (trace smart match resolution)
 33554432  B  дамп подпрограммы определения, в том числе специальные блоки (dump suBroutine definitions, including special Block)
              like НАЧАЛО

Все эти флаги требуют B<-DDEBUGGING> при компиляции исполняемого Perl (но см. C<:opd> в L<Devel::Peek> или L<re/'debug' mode> которые могут изменить это).
См. F<INSTALL> файл в исходных файлах Perl'а, как это сделать.  Этот флаг устанавливается автоматически, если вы включите B<-g> опцию, когда C<Configure> спрашивает вас об оптимизаторе/отладчике флагов.

Если вы просто пытаются получить печать из каждой строки кода Perl, как он выполняет, таким образом, что C<sh -x>  предоставляет для shell скриптов, вы не можете использовать Perl-вый B<-D> ключ.  Вместо того, чтобы сделать это

  # Если у вас есть утилита "env"
  env PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS program

  # Синтаксис оболочки (Bourne shell syntax)
  $ PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS program

  # синтаксис csh
  % (setenv PERLDB_OPTS "NonStop=1 AutoTrace=1 frame=2"; perl -dS program)

См. L<perldebug> для деталей и вариаций.

=item B<-e> I<commandline>
X<-e>

может быть использован для ввода одной строки программы.  Если B<-e> задано, Perl не будет искать имя файла в списке аргументов.  Несколько B<-e> команд может быть дано, чтобы построить многострочный сценарий.  Убедитесь в том, что вы используете точку с запятой там, где вы были использовали ее в нормальной программе.

=item B<-E> I<commandline>
X<-E>

ведет себя так же, как B<-e>, за исключением того, что она неявно включает все дополнительные функции (в основном блоке компиляции, например say). См. L<feature>.

=item B<-f>
X<-f> X<sitecustomize> X<sitecustomize.pl>

Отключает выполнение F<$Config{sitelib}/sitecustomize.pl> при запуске.

Perl может быть построен так, что он по умолчанию будет пытаться выполнить F<$Config{sitelib}/sitecustomize.pl> при запуске (в блоке BEGIN).
Это крючок, который позволяет системному администратору настраивать поведение Perl.
Он может, например, использоваться для добавления записей в массив @INC, чтобы найти Perl модули в нестандартных местах.

Perl на самом деле вставляет следующий код:

    BEGIN {
        do { local $!; -f "$Config{sitelib}/sitecustomize.pl"; }
            && do "$Config{sitelib}/sitecustomize.pl";
    }

Поскольку это фактические C<do> (не C<require>), F<sitecustomize.pl> не нужно возвращать истинное значение. Код выполняется в пакете C<main>, в своей собственной лексической области. Однако, если сценарий умирает (dies), C<$@> не будет установлен.

Значение C<$Config{sitelib}> также определяется в коде C и не считывается из C<Config.pm> , который не загружен.

Код выполняется I<очень> рано. Например, любые изменения, внесенные в C<@INC> будут отображаться в результатах `perl -V` Конечно, C<END> блоки будут также выполнены очень поздно.

Чтобы определить, во время выполнения, если эта возможность была скомпилирована в вашем Perl, вы можете проверить значение  C<$Config{usesitecustomize}>.

=item B<-F>I<pattern>
X<-F>

указвывает шаблон для разделения, также можно использовать B<-a>.  Шаблон может быть окружен C<//>, C<"">, или C<''> в противном случае он будет поставлен в одинарные кавычки. Вы не можете использовать буквальные пробелы в шаблоне.

=item B<-h>
X<-h>

выдает список опций.

=item B<-i>[I<extension>]
X<-i> X<in-place>

указывает, что файлы, обрабатываемые конструкцией C<E<lt>E<gt>> , будут отредактированы на месте (edited in-place).  Он делает это путем переименования входного файла, открытия выходного файла по оригинальному названию, и выбора, что выходной файл является файлом по умолчанию для оператора print().  Расширение, если имеются, используется для изменения названия старых файлов, чтобы сделать резервную копию, следуя этим правилам:

Если расширение не указано, и ваша система поддерживает его, оригинальный I<файл> остается открытым без имени в то время как вывод будет перенаправлен в новый файл с оригинальным I<именем> .  Когда Perl выходит, чисто или нет, исходный I<файл> удаляется (unlinked).

Если расширение не содержит C<*>, то оно добавляется к концу текущего файла в качестве суффикса.  Если расширение содержит один или более символов  C<*>, то каждый  C<*> заменяется с текущим именем файла.  В Perl терминах, вы можете думать об этом как:

    ($backup = $extension) =~ s/\*/$file_name/g;

Это позволяет добавить префикс к файлу резервной копии, вместо (или в дополнение к) суффикса:

 $ perl -pi'orig_*' -e 's/bar/baz/' fileA  # резервирует файл в (backup to)
                                           # 'orig_fileA'

Или даже размещает резервные копии оригинальных файлов в другом каталоге (при условии, что каталог уже существует):

 $ perl -pi'old/*.orig' -e 's/bar/baz/' fileA  # делает бекап (backup to)
                                               # 'old/fileA.orig'

Эти наборы однострочников (one-liners) эквивалентны:

 $ perl -pi -e 's/bar/baz/' fileA          # перезаписать текущий файл
 $ perl -pi'*' -e 's/bar/baz/' fileA       # перезаписать текущий файл

 $ perl -pi'.orig' -e 's/bar/baz/' fileA   # backup to 'fileA.orig'
 $ perl -pi'*.orig' -e 's/bar/baz/' fileA  # backup to 'fileA.orig'

Из shell, говоря

    $ perl -p -i.orig -e "s/foo/bar/; ... "

так же, как с помощью программы:

    #!/usr/bin/perl -pi.orig
    s/foo/bar/;

что эквивалентно

    #!/usr/bin/perl
    $extension = '.orig';
    LINE: while (<>) {
	if ($ARGV ne $oldargv) {
	    if ($extension !~ /\*/) {
		$backup = $ARGV . $extension;
	    }
	    else {
		($backup = $extension) =~ s/\*/$ARGV/g;
	    }
	    rename($ARGV, $backup);
	    open(ARGVOUT, ">$ARGV");
	    select(ARGVOUT);
	    $oldargv = $ARGV;
	}
	s/foo/bar/;
    }
    continue {
	print;	# здесь напечатается исходное имя файла
    }
    select(STDOUT);

исключением того, что форму B<-i> не нужно сравнивать $ARGV в $oldargv чтобы знать, когда файл был изменен.  Это, однако, использует ARGVOUT для выбранного дескриптор файла.  Обратите внимание, что STDOUT восстанавливается как дескриптор файла вывода по умолчанию после цикла.

Как было показано выше, Perl создает файл резервной копии в независимости было ли что-либо изменено.  Так что это всего лишь причудливый способ для копирования файлов:

    $ perl -p -i'/some/file/path/*' -e 1 file1 file2 file3...
или
    $ perl -p -i'.orig' -e 1 file1 file2 file3...

Вы можете использовать C<eof> без скобок, чтобы найти в конце каждого входного файла, в случае, если вы хотите добавить к каждому файлу, или сбросить нумерацию строк (см. пример в L<perlfunc/eof>).

Если для данного файла, Perl не может создать файл резервной копии, как указано в расширении, то он пропустит этот файл и продолжить работу со следующей задачей (если она существует).

Для обсуждения вопросов, связанных с правами доступа к файлам и B<-i>, см. L<perlfaq5/Why does Perl let me delete read-only files? (Почему Perl даёт мне удалить файлы только для чтения?)  Почему -i разбивает (clobber) защищенные файлы?  Разве это не ошибка в Perl?>.

Вы не можете использовать B<-i> для создания каталогов или для обрезания расширений файлов.

Perl не интерполирует C<~> в именах файлов, и это хорошо, так как некоторые люди используют его для своих файлов резервных копий:

    $ perl -pi~ -e 's/foo/bar/' file1 file2 file3...

Отметим, что поскольку B<-i> переименовывает или удаляет исходный файл перед созданием нового файла с таким же названием, Unix-стиль мягкие и жесткие ссылки не будут сохранены.

Наконец, опция  B<-i> не препятствует исполнению, когда файлы не заданы в командной строке.  В этом случае резервная копия не делается (исходный файл не может, конечно, быть определен), и обработка переходит со стандартного ввода (STDIN) на стандартный вывод (STDOUT), как можно было ожидать.

=item B<-I>I<directory>
X<-I> X<@INC>

Каталоги, указанные B<-I> вставляются в пути поиска модулей (C<@INC>).

=item B<-l>[I<octnum>]
X<-l> X<$/> X<$\>

обеспечивает автоматическое завершения строк обработки.  Она состоит из двух отдельных эффектов.  Во-первых, он автоматически обрезает (chomps) C<$/> (разделитель входных записей) при использовании B<-n> или B<-p>.  Во-вторых, он присваивает C<$\> (разделителю выходных записей), чтобы иметь значение I<octnum> (I<восьмиричное число>) так что любые операторы печати будут иметь разделитель выданный обратно (will have that separator added back on).
Если  I<octnum>> опущен, устанавливает C<$\>; для текущего значения как C<$/>.  Например, для обрезки линий до 80 символов/столбцов (columns):

    perl -lpe 'substr($_, 80) = ""'

Обратите внимание, что назначение  C<$\ = $/> делается, когда переключатель обрабатывается, поэтому разделитель входных записей может отличаться от разделителя выходных записей, если ключ B<-l> следует за ключом B<-0>:

    gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

Этот параметр определяет, C<$\> как символ новой строки, а затем устанавливает C<$/> в нулевой символ.

=item B<-m>[B<->]I<module>
X<-m> X<-M>

=item B<-M>[B<->]I<module>

=item B<-M>[B<->]I<'module ...'>

=item B<-[mM]>[B<->]I<module=arg[,arg]...>

B<-m>I<module> выполняет C<use> I<module> C<();> перед выполнением программы.

B<-M>I<module> выполняет C<use> I<module> C<;> перед выполнением программы.  Вы можете использовать кавычки, чтобы добавить дополнительный код после имени модуля, например, C<'-MI<MODULE> qw(foo bar)'>.

Если первый символ после  B<-M> или B<-m> является тире (B<->), то «использование» заменяется на «нет».

Немного встроенного синтаксического сахара означает, что вы можете также сказать, B<-mI<MODULE>=foo,bar> или  B<-MI<MODULE>=foo,bar> в качестве ярлыка для B<'-MI<MODULE> qw(foo bar)'>.  Это позволяет избежать необходимости использовать кавычки при импорте символов.  Фактический код, генерируемый B<-MI<MODULE>=foo,bar> является C<use module split(/,/,q{foo,bar})>.  Обратите внимание, что форма C<=>  стирает различие между B<-m> и B<-M>.

Следствием этого является то, что B<-MI<MODULE>=number> никогда не делает проверку версии, если C<I<MODULE>::import()>> сам настроен сделать проверку версий, что может произойти, например, если I<MODULE> наследует от L<Exporter> .

=item B<-n>
X<-n>

вызывает Perl предположить следующий цикл вокруг вашей программы, который перебирает аргументы файлы также, как I<sed -n> или I<awk> :

  LINE:
    while (<>) {
	...		# ваша программа идет здесь
    }

Следует отметить, что строки не выводятся (not printed) по умолчанию.  См. L</-p> чтобы иметь напечатанные строки.  Если файл, названный в аргументе не может быть открыт по некоторым причинам, Perl предупреждает вас об этом и переходит к следующему файлу.

Также отметим, что C<< <> >> передает аргументы командной строки для L<perlfunc/open> , которая не обязательно будет интерпретировать их как имена файлов.
См. L<perlop> за возможные последствия для безопасности.

Вот эффективный способ, чтобы удалить все файлы, которые не были изменены в течение по крайней мере недели:

    find . -mtime +7 -print | perl -nle unlink

Это быстрее, чем при использовании опцию B<-exec> у I<find>, потому что вы не должны запускать процесс на каждом найденном файле.  Он страдает от неправильного обращения ошибка в строки символ новой строки в путях (pathnames), которые можно исправить, если вы будете следовать, например, под B<-0>.

C<BEGIN> и C<END> блоки могут быть использованы для захвата управления до или после неявного цикла программы, как и в I<awk>.

=item B<-p>
X<-p>

заставляет Perl сделать следующий цикл вокруг вашей программы, что делает перебор аргументов файла в некоторой части, как в I<sed>:


  LINE:
    while (<>) {
	...		# ваша программа идет здесь
    } continue {
	print or die "-p destination: $!\n";
    }

Если файл, указанный в аргументе не может быть открыт по некоторым причинам, Perl предупреждает вас об этом, и переходит к следующему файлу.  Следует отметить, что строки печатаются автоматически.  Ошибка, произошедшая во время печати рассматриваются как фатальная.  Чтобы подавить печать используйте флаг B<-n>.  A B<-p>
отменяет флаг B<-n>.

C<BEGIN> и C<END> Блоки могут быть использованы для захвата управления до или после неявного цикла, как и в I<awk>.

=item B<-s>
X<-s>

позволяет рудиментарной разбора переключателем для переключателей в командной строке после имени программы, но до любого аргумента файла (или перед аргументом B<-->).  Любая обнаруженная опция удаляется из @ARGV и устанавливает соответствующую переменную в Perl программе.  Следующая программа выводит "1", если программа вызывается с опцией B<-xyz> и "abc"
если она вызывается с B<-xyz=abc>.

    #!/usr/bin/perl -s
    if ($xyz) { print "$xyz\n" }

Заметьте, что, как переключатель B<--help> создает переменную  C<${-help}>, который не соответствует C<use strict "refs">.  Кроме того, при использовании этой опции на сценарии с включенными  предупреждениями вы можете получить много ложных "используется только один раз" ("used only once") предупреждений.

=item B<-S>
X<-S>

Perl позволяет использовать переменную окружения PATH для поиска программы, если имя программы не содержит разделителей пути.

На некоторых платформах, это также делает Perl добавления суффикса к имени файла при поиске его.  Например, на платформах Win32 ". суффиксы  ".bat" и ".cmd" добавляются, если поиск по оригинальному названию не удается, и если имя еще не закончится в одном из этих суффиксов.  Если ваш Perl был скомпилирован с включенной опцией C<DEBUGGING>, используя опцию B<-Dp> Perl покажет как продвигается поиск.

Обычно это используется для эмуляции  C<#!> запуска на платформах, которые не поддерживают  C<#!>.  Это также удобно при отладке скрипта, который использует  C<#!>, и, таким образом, обычно находящиеся на в области поиска shell $PATH.

Этот пример работает на многих платформах, которые имеют совместимость с оболочкой Bourne (Bourne shell):

    #!/usr/bin/perl
    eval 'exec /usr/bin/perl -wS $0 ${1+"$@"}'
	    if $running_under_some_shell;

Система игнорирует первую линию и подает программу F</bin/sh>, которая продолжает пробовать выполнить Perl программу как сценарий оболочки.
Шелл (Shell) выполняет вторую строку как обычную команду shell , и, таким образом запускает интерпретатор Perl.  На некоторых системах $0 не всегда содержит полный путь, так что B<-S> говорит Perl путь для поиска программы в случае необходимости.  После Perl находит программу, он анализирует линии и игнорирует их, потому что переменная $running_under_some_shell никогда не верно.  Если программа будет интерпретирован csh, вы, нужно будет заменить  C<${1+"$@"}> на C<$*>, хотя это не понимает пробелы (и такой) в списке аргументов .  Для запуска  I<sh> , а не I<csh>, некоторые системы, возможно, придется заменить строку с  C<#!> строкой содержащей только двоеточие, которая будет вежливо игнорироваться Perl.  Другие системы не могут контролировать это, и нужно полностью окольные конструкцию, которая будет работать под любой из  I<csh>, I<sh>, или Perl, такие как следующие:

	eval '(exit $?0)' && eval 'exec perl -wS $0 ${1+"$@"}'
	& eval 'exec /usr/bin/perl -wS $0 $argv:q'
		if $running_under_some_shell;

Если имя файла содержит разделители директорий (и поэтому абсолютный или относительный путь), и, если этот файл не найден, платформа, которая добавляют расширения файлов сделает это и попытается искать файл с этими добавленным расширениями, один за другим.

На DOS-подобных платформах, если программа не содержит разделителей директорий, то он сначала будет искаться в текущем каталоге, прежде чем искать в PATH.  В Unix платформ, программа будет искать строго в PATH.

=item B<-t>
X<-t>

Как и B<-T>, но проверки заразы (разрушения) будет выносить предупреждения, а не фатальных ошибок.  Этими предупреждениями теперь можно управлять нормально с C<no warnings qw(taint)>.

B<Замечание: Это не заменяет C<-T>!> Это должно быть использовано I<только> в качестве временной помощи в целях развития при обеспечении унаследованного кода: для реального кода производства и новый безопасный код, написанный с нуля, всегда использует реальный B<-T>.

=item B<-T>
X<-T>

переключает в "клеймо" ("taint"), поэтому вы можете проверить их.  Обычно эти проверки осуществляются только при работе SETUID или SETGID.  Это хорошая идея, чтобы включить их явно для программы, которые работают от чужого имени, которым вы не обязательно будете доверять, таких, как программы CGI или любого интернет-серверов, вы можете написать в Perl.  См.
L<perlsec> для деталей.  По соображениям безопасности, эта опция должна быть определена в Perl как можно раньше, обычно это означает, что он должен появиться на раннем этапе в командной строке или в строке C<#!> для систем, которые поддерживают такую конструкцию.

=item B<-u>
X<-u>

Этот выключатель принуждает Perl сваливать ядро ​​в дамп после компиляции программы (This switch causes Perl to dump core after compiling your program.).  Затем можно теоретически воспользоваться этим дампом и превратить его в исполняемый файл с помощью программы I<undump> (не прилагается).
Это ускоряет запуск за счет некоторого дискового пространства (которое можно свести к минимуму путем удаления исполняемого файла).  (Тем не менее, "привет мир" исполняемый файл выходит около 200K на моей машине.) Если вы хотите, чтобы выполнить часть вашей программы перед дампом, используйте вместо этого оператор dump().  Примечание: наличие I<undump> зависит от платформы и может быть  не доступно для конкретного порта Perl.

=item B<-U>
X<-U>

позволяет Perl делать небезопасные операции.  В настоящее время единственной «небезопасной» операцией  является пытка разорвать связь между каталогами, тогда, когда нет  привилегий суперпользователя и работает SETUID программа со смертельными проверками меток (taint), которые превращаются в предупреждения.
Обратите внимание, что предупреждения (warnings) должны быть включены вместе с этим параметром, чтобы на самом деле I <генерировать> предупреждения метко-проверки (taint-check warnings).

=item B<-v>
X<-v>

выдает номер версии и патч (patchlevel) вашего исполняемого perl файл.

=item B<-V>
X<-V>

выдает сводную таблицу основных значений конфигурации Perl и текущие значения @INC.

=item B<-V:>I<configvar>

Печатает на стандартный вывод (STDOUT) значение указанной переменной конфигурации или несколько переменных, если ваш C<I<configvar>> аргумент выглядит как регулярное выражение (содержит небуквы).  Например:

    $ perl -V:libc
	libc='/lib/libc-2.2.4.so';
    $ perl -V:lib.
	libs='-lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lc';
	libc='/lib/libc-2.2.4.so';
    $ perl -V:lib.*
	libpth='/usr/local/lib /lib /usr/lib';
	libs='-lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lc';
	lib_ext='.a';
	libc='/lib/libc-2.2.4.so';
	libperl='libperl.a';
	....

Кроме того, дополнительное двоеточие может быть использовано для управления форматированием.  Двоеточие подавляет перевод строки и терминатор ";", что позволяет вставлять запросы в команды оболочки (shell commands).  (мнемоника: разделитель (separator) PATH 
":".)

    $ echo "сжатые-переменные: " `perl -V:z.*: ` " уже здесь !"
    сжатые-переменные:  zcat='' zip='zip' уже здесь !

Ведущее двоеточие удаляет "name =" часть ответа, это позволяет отображать в имени. (A leading colon removes the "name=" part of the response, this allows
you to map to the name you need.)  (мнемоника: пустые метки)

    $ echo "goodvfork="`./perl -Ilib -V::usevfork`
    goodvfork=false;

Начальные и конечные двоеточия могут быть использованы вместе, если вам нужно значения позиционных параметров без имен.  Следует отметить, что в том случае, ниже, C<PERL_API> параметры возвращаются в алфавитном порядке.

    $ echo building_on `perl -V::osname: -V::PERL_API_.*:` now
    building_on 'linux' '5' '1' '9' now

=item B<-w>
X<-w>

печать предупреждения о сомнительных конструкций, таких как имена переменных упоминается только один раз и скалярных переменных, используемых, прежде чем установить; пересмотрены подпрограмм; ссылки на неопределенные дескрипторов файлов дескрипторов файлов открыт только для чтения, который вы пытаетесь писать на; значения, используемые как число, которое вы не должны I<видеть> как числа; использованием массива, как если бы это был скалярного, если ваш подпрограммы имеют рекурсию глубиной более 100 вложений, и бесчисленное множество других вещей.

Этот переключатель позволяет включить только глобальную C<$^W> переменную, обычно, лексически C<use warnings> Pragma является предпочтительной. Вы можете отключить или продвижения в фатальные ошибки конкретные предупреждения использованием хука C<__WARN__> , как описано в L<perlvar> и L<perlfunc/warn> .
См. также  L<perldiag> и L<perltrap>.  Мелкозернистой средство предупреждения также доступна, если вы хотите управлять целыми классами предупреждения, см. L<warnings> или L<perllexwarn> .

=item B<-W>
X<-W>

Включает все предупреждения, независимо от C<no warnings> или C<$^W>.
See L<perllexwarn>.

=item B<-X>
X<-X>

Отключает все предупреждения независимо от C<use warnings> или C<$^W>.
See L<perllexwarn>.

=item B<-x>
X<-x>

=item B<-x>I<directory>

говорит Perl, что программа встраивается в большой кусок текста не связаны, например, в почтовом сообщении.  Ведущие мусора не будет отброшен до первой строке, которая начинается с  C<#!> и содержит строку "Perl".  Любое значимое переключателей на этой строке будет применяться.

Все ссылки на номер строки в программе (предупреждения, ошибки, ...) будут относиться к C<#!> как к первой строке.
Таким образом, предупреждение на 2-й строке программы, которая находится на 100-й строчку в файле будут представлены как линии 2, а не как строка 100.
Это может быть переопределено с помощью директивы C<#line>.
(См. L<perlsyn/"Plain Old Comments (Not!)">)

Если имя каталога указано, Perl будет переключаться в этот каталог перед запуском программы.  Опция B<-x> управляет только сбросом ведущего мусор.  Программа должна быть прекращена с C<__END__> если есть задний мусор должен быть проигнорирован, программа может обрабатывать любой или все из задней мусора через C<DATA> дескриптор файла при желании.

Каталог, если указан, должен появиться сразу же после B<-x> без промежуточных пробелов.

=back

=head1 ОКРУЖЕНИЕ (ENVIRONMENT)
X<perl, environment variables>

=over 12

=item HOME
X<HOME>

Используется, если C<chdir> не имеет аргументов.

=item LOGDIR
X<LOGDIR>

Используется, если C<chdir> не имеет аргументов и HOME не установлен.

=item PATH
X<PATH>

Используется для выполнения подпроцессов, и в поиске программы, если используется B<-S>.

=item PERL5LIB
X<PERL5LIB>

Список каталогов, в которых следует искать файлы Perl библиотеки, прежде чем искать в стандартной библиотеке и текущем каталоге.  Любой конкретной архитектуры и конкретных версий каталогов, таких как F<version/archname/>, F<version/> или F<archname/> по указанной директории, они автоматически включаются, если они существуют, интерпретатор ищет там во время запуска.  Кроме того, любые каталоги, соответствующие записи в C<$Config{inc_version_list}> будут добавлены.
(Они обычно были бы для старой совместимости Perl версии устанавливаются в том же дереве каталогов.)

Если PERL5LIB не определена, PERLLIB используется.  Каталоги разделяются (как в PATH) двоеточие на Unixi платформах и точки с запятой в Windows (правильный разделитель пути дается командой C<perl
-V:I<path_sep>>).

При запуске проверок меток ( taint checks), либо потому, что программа работает SETUID или SETGID или B<-T> или B<-t> опции были указаны ни PERL5LIB ни PERLLIB не спрашиваются. Программа должна вместо этого сказать:

    use lib "/my/directory";

=item PERL5OPT
X<PERL5OPT>

Параметры командной строки (switches) переключатели.  Опции в этой переменной, рассматриваются как если бы они были на каждом Perl командной строки.  Только B &lt;- [CDIMUdmtwW]&gt; переключатели допускается.  При запуске проверки меток (taint check) (либо потому, что программа работает SETUID или SETGID, или потому что были использованы ключи B<-T> или B<-t>), эта переменная игнорируется.  Если PERL5OPT начинается с B<-T>, заражение(tainting) будет включена и последующие варианты игнорируются.  Если PERL5OPT начинается с B<-t>, заражение(tainting) будет включено, точка удаляется из @INC, и последующие опции учитываются (subsequent options honored).

=item PERLIO
X<PERLIO>

Пробелы (или доеточия) разделенный список PerlIO слоев. Если Perl построен использовать PerlIO как систему ввода-вывода (по умолчанию) эти слои влияют на IO Perl.

Принято, чтобы начать имена слоев с двоеточия (например, C<:perlio>), чтобы подчеркнуть их сходство с переменной "атрибуты". Но код, который анализирует спецификации уровня строк, который также используется для декодирования переменной PERLIO среды, лечится двоеточием в качестве разделителя.

Установлен или пустые PERLIO эквивалентна по умолчанию набор слоев для вашей платформы, например, C<:unix:perlio> на Unix-подобных системах и C<:unix:crlf> на Windows и других DOS-подобных систем.

Список будет использоваться по умолчанию для I<всех> IO Perl. Следовательно только встроенные слои могут появиться в этом списке, в качестве внешних слоев (например, C<:encoding()>) IO нужно для того, чтобы загрузить их!  См. L<"open pragma"|open>, как добавить внешнюю кодировку по умолчанию.

Слои имеет смысл включить в переменную среды PERLIO кратко изложены ниже. Для получения дополнительной информации см. L<PerlIO>.

=over 8

=item :bytes
X<:bytes>

Псевдолой, который превращает флаг  C<:utf8> I<off> (I<выключено>) для слоя ниже; вряд ли будет полезна сама по себе в глобальной переменной окружения PERLIO.
Вы, возможно, думали о C<:crlf:bytes> или C<:perlio:bytes>.

=item :crlf
X<:crlf>

Слой, который делает СRLF для  C<"\n"> перевод различия "текст" и "двоичный" файлы в виде MS-DOS и аналогичные операционных систем.
(В настоящее время она I<не> имитировать MS-DOS, насколько лечении Control-Z как конец файла маркер.)

=item :mmap
X<:mmap>

Слой, который реализует «чтения» файлов с помощью I<mmap> (2), чтобы сделать весь файл отображается в адресное пространство процесса, а затем он используется в качестве «буфера» PerlIO.

=item :perlio
X<:perlio>

Это вновь осуществления STDIO-подобный буферизации виде слоя PerlIO.  Как таковой, он будет вызывать все, что слой под ним для осуществления своей деятельности, обычно  C<:unix>.

=item :pop
X<:pop>

Экспериментальные псевдослой (pseudolayer), который удаляет верхний слой.
Используйте с такой же тщательностью, как зарезервировано для нитроглицерина.

=item :raw
X<:raw>

Псевдослой (Pseudolayer) который манипулирует другими слоями.  Применив C<:raw> слой эквивалентен вызову C<binmode($fh)>.  Это делает поток проходит каждый байт как есть без перевода.  В частности, оба CRLF перевода и созерцание C<:utf8> из локали отключены.

В отличие от более ранних версий Perl, C<:raw> I<не> просто обратная C<:crlf>: другие слои, которые будут влиять на двоичный характер потока также удалить или отключить.

=item :stdio
X<:stdio>

Этот уровень предоставляет PerlIO интерфейс, обернув системе ANSI C "STDIO" вызовы библиотеки. Слой обеспечивает как буферизации и ввода-вывода.
Следует отметить, что C<:stdio> слой делает I<не> CRLF сделать перевод даже, если это нормальное поведение платформы. Вы будете нуждаться в  C<:crlf> слой над ним, чтобы сделать это.

=item :unix
X<:unix>

Низкий уровень слоя, который вызывает C<read> , C<write> , C<lseek> и т.д.

=item :utf8
X<:utf8>

Псевдослой (Pseudolayer), который включает флаг в слое ниже, чтобы сказать, что Perl вывод должен быть в utf8 и что материалы следует считать уже в utf8 действительны форме. B <WARNING: Он не проверяет на достоверность и как таковой должны быть обработаны с особой осторожностью для ввода, так как нарушения безопасности могут происходиять с не-кратчайший UTF-8 кодировках, и т.д..> Вообще C<:encoding(utf8)> является наилучшим вариантом при чтении UTF-8 закодированных данных.

=item :win32
X<:win32>

На платформе Win32 это I<экспериментальный> уровень использует родной "ручки" IO, а не Unix-подобных числовых слоя дескриптор файла. Известный как детский баг(buggy) в этой версии (5.14).

=back

По умолчанию набор слоев должны дать приемлемые результаты на всех платформах

Для Unix платформ, которые будут эквивалент "UNIX PerlIO" или "STDIO".
Настройка настроена предпочтительность "STDIO" реализацию, если библиотеки системы обеспечивает быстрый доступ к буферу, в противном случае, он использует "UNIX PerlIO" реализации.

В Win32 по умолчанию в этой версии (5.14) является  "unix crlf". Win32 в "stdio" имеет ряд ошибок/MIS-функций (bugs/mis-features) для Perl IO которых несколько в зависимости от версии и поставщик компилятора C. Используя нашу собственную  C<crlf> слоя в качестве буфера позволяет избежать этих проблем и делает вещи более равномерным.  C<crlf> CRLF слой обеспечивает преобразование а также буферизации.

Этот релиз (5.14) использует C<unix> в качестве нижнего слоя на Win32, и так до сих пор использует компилятора C. числовые процедуры дескриптор файла. Существует экспериментальная родной C<win32> слой, который как ожидается, будет повышена и должна в конечном итоге стать по умолчанию под Win32.

Переменная PERLIO среда полностью игнорируется при Perl выполняется в данном режиме.

=item PERLIO_DEBUG
X<PERLIO_DEBUG>

Если установлено имя файла или устройства, определенные операции PerlIO подсистемы будут записываться в этот файл, который открывается в режиме добавления.
Типичное применение: Unix:

   % env PERLIO_DEBUG=/dev/tty perl script ...

и под Win32, приблизительно эквивалентны:

   > set PERLIO_DEBUG=CON
   Perl скрипт ...

Эта функция отключена для SETUID скрипты и скрипты для запуска с B<-T>.

=item PERLLIB
X<PERLLIB>

Список каталогов, в которых следует искать файлы Perl библиотеки, прежде чем искать в стандартной библиотеке и текущий каталог.
Если PERL5LIB определено, PERLLIB не используется.

PERLLIB переменной окружения полностью игнорируется, когда Perl выполняется в данном режиме.

=item PERL5DB
X<PERL5DB>

Команда используется для загрузки кода отладчика.  Значение по умолчанию:

	BEGIN { require "perl5db.pl" }

PERL5DB переменная среды используется только при Perl запускается с голой B<-d> переключатель.

=item PERL5DB_THREADED
X<PERL5DB_THREADED>

Если установлена ​​в истинное значение, указывает, что отладчик кода отлаживаемой использует потоки.

=item PERL5SHELL (specific to the Win32 port)
X<PERL5SHELL>

В Win32 только порты, может быть установлен в альтернативную оболочку, которая должна использовать Perl внутренне для выполнения "обратные" ("backtick") команды или system().  По умолчанию C<cmd.exe /x/d/c> на WindowsNT и C<command.com /c> на Windows 95.  Значение считается пробел.  Предшествовать любой символ, который нуждается в защите, как и пространство или обратную косую черту, с другой косой чертой.

Следует отметить, что Perl не использует COMSPEC для этой цели, поскольку COMSPEC имеет высокую степень изменчивости среди пользователей, что приводит к переносимости проблем.  Кроме того, можно использовать Perl оболочку, которая не может быть пригодным для интерактивного использования и настройки COMSPEC такой оболочке может повлиять надлежащего функционирования других программ (которые обычно смотрят в COMSPEC найти оболочке, пригодный для интерактивного использования).

До Perl 5.10.0 и 5.8.8, PERL5SHELL было не испортить проверены при выполнении внешних команд.  Рекомендуется, чтобы вы явно установить (или удалить) C<$ENV{PERL5SHELL}> при работе в данном режиме под Windows.

=item PERL_ALLOW_NON_IFS_LSP (специфичные для Win32 порт)
X<PERL_ALLOW_NON_IFS_LSP>

Установите 1, чтобы разрешить использование не-IFS LSP, совместимы (многоуровневые службы).
Perl обычно ищет IFS-совместимых LSP, потому что это требуется для его эмуляции интерфейс Windows Sockets как реальные дескрипторов файлов.  Однако, это может вызвать проблемы, если у вас есть брандмауэр, таких как я <McAfee Guardian> , Который требует, чтобы все приложения используют ее LSP но который не является IFS-совместимы, потому что ясно Perl, как правило, не использовать такие LSP.

Установка этой переменной среды 1 означает, что Perl просто будет использовать только первый подходящий LSP перечисленных в каталоге, который держит I<McAfee Guardian> счастливым - и в этом конкретном случае Perl все еще работает, потому что я слишком I<McAfee Guardian> на самом деле играет LSP других игр, которые позволяют приложениям IFS требующих совместимости на работу.

=item PERL_DEBUG_MSTATS
X<PERL_DEBUG_MSTATS>

Релевантно только в Perl скомпилирован с C<malloc> входит в Perl распределения, то есть, если C<perl -V:d_mymalloc> будет "определен".

Если установлено, дамп памяти статистику после выполнения.  Если установлено значение целое число больше единицы, также выводит из статистики использования памяти после компиляции.

=item PERL_DESTRUCT_LEVEL
X<PERL_DESTRUCT_LEVEL>

Соответствующие только если ваш Perl исполняемый был построен с B<-DDEBUGGING>, это управляет поведением глобального уничтожения объектов и др. Ссылки.  See L<perlhacktips/PERL_DESTRUCT_LEVEL> для получения дополнительной информации.

=item PERL_DL_NONLAZY
X<PERL_DL_NONLAZY>

Установите в  C<"1">  иметь Perl решения я <all> неопределенных символов при загрузке динамической библиотеки.  Поведение по умолчанию заключается в разрешении символы, когда они используются.  Установка этой переменной может пригодиться во время тестирования расширений, так как он гарантирует, что вы получите сообщение об ошибке на орфографическими ошибками имена функций, даже если набор тестов не называет их.

=item PERL_ENCODING
X<PERL_ENCODING>

При использовании C<use encoding> Pragma без явного именем кодировки, PERL_ENCODING переменная окружения консультировал имя кодировки.

=item PERL_HASH_SEED
X<PERL_HASH_SEED>

(Так как Perl 5.8.1, новой семантике Perl 5.18.0) Используется для переопределения рандомизации внутренней хэш-функции Perl. Значение выражается в шестнадцатеричном, и может включать лидирующий 0x. Усеченный шаблоны обрабатываются как будто они суффикс достаточной 0, как это требуется.

Если опция предусмотрена, и C<PERL_PERTURB_KEYS> не установлен, то значение '0 'означает C<PERL_PERTURB_KEYS=0> и любое другое значение означает C<PERL_PERTURB_KEYS=2> .

B <ПОЖАЛУЙСТА, ОБРАТИТЕ ВНИМАНИЕ: хэш ключи  чувствительно к информации> . Хэши рандомизированных для защиты от удаленных и локальных атак против кода Perl. Путем ручной настройки семян, эта защита может быть частично или полностью потеряны.

См. L<perlsec/"Algorithmic Complexity Attacks"> and L</PERL_PERTURB_KEYS>
L</PERL_HASH_SEED_DEBUG>  для получения дополнительной информации.

=item PERL_PERTURB_KEYS
X<PERL_PERTURB_KEYS>

(Так как Perl 5.18.0) Установите в  C<"0"> или C<"NO"> Затем клавишами перемещения будет повторяемые от запуска к запуску по той же PERL_HASH_SEED.
Установка в хэш не изменит порядка, кроме как для оказания за больше места в хэш. В сочетании с установкой PERL_HASH_SEED этот режим как можно ближе к предварительно 5,18 поведения как вы можете получить.

При установке на C<"1"> или C<"RANDOM"> Затем клавишами перемещения будут рандомизированы.
Каждый раз, когда хэш вставляется в порядок ключей будет изменяться случайным образом. Чтобы не может быть повторяемым в следующем запуске программы, даже если PERL_HASH_SEED был указан. Это режим по умолчанию для Perl.

При установке на  C<"2"> или C<"DETERMINISTIC"> ; со вставкой ключей в хэш причинит ключевой для изменения, но таким образом, что повторяется от программы запуска на выполнение программы.

B <ПРИМЕЧАНИЕ:> Использование этой опции считается небезопасной, и предназначен только для отладки недетерминированное поведения в хэш-функции Perl. Не используйте его в продакшене.

См. L<perlsec/"Algorithmic Complexity Attacks"> и L</PERL_HASH_SEED>
и L</PERL_HASH_SEED_DEBUG> для получения дополнительной информации. Вы можете получать и устанавливать ключ обхода маску для конкретной хэш с помощью C<hash_traversal_mask()> функции из L<Hash::Util> .

=item PERL_HASH_SEED_DEBUG
X<PERL_HASH_SEED_DEBUG>

(Так как Perl 5.8.1.) Установите в C<"1"> для отображения (на стандартный вывод ошибок STDERR) информации о хэш-функция, семена, и какой тип ключевых рандомизации обхода в силу в начале исполнения.  Это, в сочетании с L</PERL_HASH_SEED> и L</PERL_PERTURB_KEYS> предназначена для помощи в отладке недетерминированное поведение вызвано хэш рандомизации.

B <Примечание> , что любая информация о хэш-функции, особенно хэш семя B<sensitive information> :, Зная это, можно выработать отказ в обслуживании против кода Perl, даже отдаленно, см. L<perlsec/\"Algorithmic Complexity Attacks\"> для получения дополнительной информации. B <Не разглашайте хэш семян> для людей, которые не нужно это знать. См. также C<hash_seed()> и
C<key_traversal_mask()> в L<Hash::Util>.

Результат может быть таким:

    HASH_FUNCTION = ONE_AT_A_TIME_HARD HASH_SEED = 0x652e9b9349a7a032 PERTURB_KEYS = 1 (RANDOM)

=item PERL_MEM_LOG
X<PERL_MEM_LOG>

Если ваш Perl был настроен с B<-Accflags=-DPERL_MEM_LOG>, задав переменную окружения C<PERL_MEM_LOG> позволяет записывать в журнал отладочных сообщений. Значение имеет вид  C<< <I<number>>[m][s][t] >>, где C<I<number>> это количество файловых дескрипторов вы хотите написать в (2 по умолчанию), и комбинации букв указывает, что вы хотите получить информацию о (m)emory (памяти) and/or (s)v (скалятрной переменной), optionally with (t)imestamps (опционально в датой и временем). Например, C<PERL_MEM_LOG=1mst> регистрирует все информацию на стандартный вывод. Вы можете написать другим открываемым дескрипторов файлов в различных формах:

  $ 3>foo3 PERL_MEM_LOG=3m perl ...

=item PERL_ROOT (specific to the VMS port)
X<PERL_ROOT>

Перевод скрытой коренится логическое имя, которое содержит Perl и логическое устройство для пути @INC только на VMS.  Другие логические имена, которые влияют на Perl VMS включают PERLSHR, PERL_ENV_TABLES и SYS$TIMEZONE_DIFFERENTIAL, но не являются обязательными и обсуждается в L<perlvms> и F<README.vms> в Perl распределения источника.

=item PERL_SIGNALS
X<PERL_SIGNALS>

Доступный в Perl  5.8.1 и выше.  Если установлено значение  C<"unsafe">, предварительно Perl-5.8.0 Поведение сигнала (который является непосредственным, но небезопасно) восстанавливается.  Если установлено значение C<safe> , То безопасным (но отложенные) сигналы.  См.
L<perlipc/"Deferred Signals (Safe Signals)" (Отложенные сигналы (Безопасные сигналы))>.

=item PERL_UNICODE
X<PERL_UNICODE>

Эквивалент B<-C> командной строки.  Отметим, что это не имеет значение переменной. Установка этого значения в C<"1"> не правильный путь, чтобы "включить Unicode" (что бы это означало бы).  Вы можете использовать C<"0">, чтобы "отключить Unicode", хотя (или, альтернативно, отключенное PERL_UNICODE в вашей оболочке перед запуском Perl).  См. описание B<-C> переключатель получить дополнительные сведения.

=item SYS$LOGIN (характерные для VMS порт)
X<SYS$LOGIN>

Используется, если ChDir не имеет аргументов, домашнего и LOGDIR не установлены.

=back

Perl также имеет переменные окружения, которые контролируют как Perl обрабатывает данные, специфичные для конкретного естественного языка, см. L <perllocale> .

Perl и его различные модули и компоненты, в том числе его рамках теста, иногда может сделать использование некоторых других переменных среды.  Некоторые из них являются специфическими для конкретной платформы.  Пожалуйста, обратитесь к соответствующей документации модуля и любую документацию для вашей платформы (например, L<perlsolaris>, L<perllinux>, L<perlmacosx>, L<perlwin32>, И т.д.) для переменных характерна для тех конкретных ситуациях.

Perl делает все переменные среды, доступной для программы выполняются, и передает эти по любому ребенку, он начинает процесс.
Тем не менее, программы, работающие SETUID не мешало бы выполнить следующие линии прежде чем делать что-либо еще, просто, чтобы держать людей честны:

    $ENV{PATH}  = "/bin:/usr/bin";    # or whatever you need
    $ENV{SHELL} = "/bin/sh" if exists $ENV{SHELL};
    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

=head1 ПЕРЕВОДЧИКИ

=over

=item * Николай Мишин  C<< <mishin@cpan.org> >>

=back    
