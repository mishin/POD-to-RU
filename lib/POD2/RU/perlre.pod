
=encoding UTF-8

=head1 NAME/НАИМЕНОВАНИЕ

X<регулярное выражение> X<регекс> X<регексп>

perlre - регулярные выражения Perl

=head1 ОПИСАНИЕ

Эта страница описывает синтаксис регулярных выражений в Perl.

Если вы раньше не использовали регулярные выражения, то есть быстрое введение в L<perlrequick> и более длинное в L<perlretut>.

О том, как регулярные выражения используются в поиске по шаблону,  а также различные примеры см. обсуждение C<m//>, C<s///>, C<qr//> и C<??> в L<perlop/"Regexp операторы заключения в кавычки">.


=head2 Модификаторы

Операторы поиска по шаблону имеют разные модификаторы.  Модификаторы, которые относятся к интерпретации внутри регулярных выражений  перечислены ниже.  Модификаторы, которые изменяют путь регулярного выражения, использующегося в Perl, детализированы в  L<perlop/"Regexp операторы заключения в кавычки"> и
L<perlop/"Внутренние детали парсинга конструкций в кавычках">.

=over 4

=item m
X</m> X<регекс, многострочный> X<регексп, многострочный> X<регулярное выражение, многострочный>

Представляет строку поиска, как многострочную. Разрешает метасимволам ^ и $ привязываться к промежуточным символам \n, имеющимся в тексте.

=item s
X</s> X<regex, single-line> X<regexp, single-line>
X<regular expression, single-line>

Метасимволу "точка" разрешено соответствовать \n.

Используя вместе как C</ms> позволяет "." соответствовать любому символу включая новую строку а символы "^" и "$" становятся началом и концом всего буфера.

=item i
X</i> X<regex, case-insensitive> X<regexp, case-insensitive>
X<regular expression, case-insensitive>

Игнорирует регистр символов при сопоставлении с образцом.

Если правила поиска локали включены, текущая карта символов берется из текущей локали для символов с кодом менее 255 и используются юникодные правила для больших кодовых точек.  Однако совпадение, которое будет пересекать правила Unicode / не Unicode  на границе (Ords 255/256) не удастся.  См.
L<perllocale>.

Есть целый ряд символов Юникода, которым соответствуют несколько символов в C</I>  Например, C<LATIN SMALL LIGATURE FI> должна соответствовать последовательности C</I>  Perl в настоящее время не в состоянии сделать это, когда многократные знаки находятся в образце поиска и расколоты между группировками, или когда один или больше определен количественно.  Таким образом
use charnames ':full'; #примечание переводчика

 "\N{LATIN SMALL LIGATURE FI}" =~ /fi/i;          # найдет
 "\N{LATIN SMALL LIGATURE FI}" =~ /[fi][fi]/i;    # Не найдет!
 "\N{LATIN SMALL LIGATURE FI}" =~ /fi*/i;         # Не найдет!

 # Ниже не будет соответствия, и не ясно, что было бы в $1 и $2
 # будьте честны, если это произойдет
 "\N{LATIN SMALL LIGATURE FI}" =~ /(f)(i)/i;      # Не найдет!

Perl не находит несколько символов в скобках (образующих класс), если только знак, который отображается на них прямо упоминается, и он не находит вообще, если класс символов инвертирован, что в противном случае могло бы быть очень запутанно.  См.
L<perlrecharclass/Bracketed Character Classes>, and
L<perlrecharclass/Negation>.

=item x
X</x>

Увеличивает читаемость вашего шаблона для поиска, разрешаются пробелы и комментарии.
Подробности в L</"/x">

=item p
X</p> X<regex, preserve> X<regexp, preserve>

Сохраненные части строки, такие как ${^PREMATCH}, ${^MATCH}, и
${^POSTMATCH}  доступны для использования после поиска по шаблону.

=item g и c
X</g> X</c>

Глобальный поиск совпадений, и сохранение текущей позиции после неудачного поиска.
В отличие от i, m, s и x,эти два флага влияют затрагиваем способ, которым regex используется, а не сам regex. См.
L<perlretut/"Using regular expressions in Perl" (Использоывание регулярных выражений Perl)> для получения большей информации
о модификаторах g и c.

=item a, d, l и u
X</a> X</d> X</l> X</u>

Эти модификаторы, все новые в 5.14, влияют при какая семантике кодировки (Unicode, и т.д.) используются, как описано ниже в L </модификаторы Кодировки>.}

=back

Модификаторы регулярных выражений  обычно описываются в документации, например,как " C</x> модификатор" несмотря на косую черту, разделителем может быть не только слэш.  Модификаторы C</imsxadlup>
могут также быть включены в пределах самого регулярного выражения, используя конструкцию C<(?...)> , см.  L</Extended Patterns>  (L</Расширенные Образцы>) ниже.

=head3 /x

C</x> говорит регулярному анализатору выражения игнорировать большую часть пробелов, перед которыми не стоит обратный слэш и не входящих в класс символов.  Вы можете использовать это, чтобы разбить ваше регулярное выражение на части, чтобы сделать его более читаемым.  Символ  C<#> также рассматривается как метасимвол, являющимся комментарием, как в обычном коде Perl.  Это также означает, что если вы хотите реальный пробел или символ C<#> в шаблоне поиска (вне класса характера, где они незатронуты C</x>), тогда вы должны будете или эскейпить их (используя наклонную черту влево или C<\Q...\E>) или кодировать их используя восьмеричный, шестнадцатиричный или  C<\N{}> код.  Взятые вместе, эти фичи (features) имеют большое значение для создания более читаемых регулярных выражений в Perl.  Обратите внимание, что вы должны быть осторожны, чтобы не включать разделитель шаблона в комментарий --perl не имеет никакого способа узнать, что вы не намеревались закрыть шаблон раньше.  См. удаление комментариев  в C коде в L<perlop>.  Также отметим, что все внутри C<\Q...\E> остается не зависимым от C</x>.  И заметьте, что C</x> не влияет на интерпретацию пространства в пределах одной многосимвольной конструкции.  Например, в C<\x{...}>,  независимо от модификатора C</x>,  не может быть пробелов.  То же самое для  L<quantifier|/Quantifiers> таких как C<{3}> или
C<{5,}>.  Аналогично, C<(?:...)> не может иметь пробелов между C<(>,
C<?>, и C<:>.  В пределах любых разделителей для такой конструкции, позволенные пробелы не имеют силы из-за C</x> и зависят от конструкции.  Например, C<\x{...}>  не должно быть пробелов, потому что шестнадцатеричные числа не имеют в себе пробелов.  Но, у свойств Unicode (Unicode properties) могут быть пробелы, таким образом, в C<\p{...}>  могут быть пробелы, которые следуют за правилами Unicode, для которых см. L<perluniprops/Properties accessible through \p{} and \P{}> (L <perluniprops/Свойства, доступные через \p{} и  \P{}>)
X</x>

=head3 Модификаторы Кодировки

C</d>, C</u>, C</a>, и C</l>, доступные, начиная с 5.14, называют модификаторами кодировки; они затрагивают семантику кодировки, используемую для регулярного выражения.

Модификаторы C</d>, C</u>, и  C</l> вряд ли будут иметь большое применения
вами, и таким образом, вы не должны о них очень волноваться. Они существуют для
внутреннего использования Perl, так, чтобы сложные структуры данных регулярных выражений
могли быть автоматически преобразованы в последовательную форму и позже точно воссозданы,
включая все их нюансы. Но, так как Perl не может хранить все в тайне, и
могут быть редкие случаи, где они полезны, они задокументированы здесь.

Модификатор C</a>, с другой стороны, может быть полезным. Его цель заключается в том, что он
позволяет коду работать главным образом на данных ASCII, чтобы не иметь проблем
с Unicode.

Кратко, C</l> задает кодировку, которая будет работать в любой
<L>ocale во время выполнения поиска по шаблону.

C</u> задает кодировку B<Ю>никод.

C</a> также устанавливает набор символов для Юникода, но добавляет несколько
ограничений B<A>SCII-безопасного поиска.

C</d> является старым, проблематичным, перед-5.14 B<Н>бором по умолчанию символов
поведение. Используется только для этого старого поведения.

В любой момент времени только один из этих модификаторов действует. Их
существование позволяет Perl сохранить первоначально скомпилированное поведение
регулярного выражения, независимо от действий правил, когда оно
действительно выполняется. И, если он интерполируется в больших регекс,
оригинал в правила продолжают применяться к нему и только к нему.

C</l> и C</u> модификаторы автоматически выбираются для
регулярных выражений, скомпилированных в рамках различных прагм,
и мы рекомендуем, в общем, чтобы вы использовали эти прагмы вместо
явного указания этих модификаторов. Для одной вещи, модификаторы
затрагивают только шаблоны поиска и не распространяются даже на сделанную замену
, тогда как использование прагма-директивы даёт постоянные результаты для всех
соответствующие операций в пределах их области. Например,

 s/foo/\Ubar/il

найдет "foo", используя локальные правила языкового стандарта для сопоставления без учета регистра,
но C</l> не влияет, когда работает C <\U>. Скорее всего вы
хотите, чтобы оба из них использовали локальные правила. Для этого нужно компилировать
регулярное выражение в рамках C<use locale>. Это 
неявно добавляет C</l> и применяет правила языка к C <\U>. 
Урок заключается в том, чтобы использовать  C<use locale> и не использоват явно C</l>.

Аналогичным образом было бы лучше использовать  C<use feature 'unicode_strings'>
вместо

 s/foo/\Lbar/iu

чтобы получить правила Юникода, как в бывшем C<\L> (но не обязательно
последнем) будет также использовать правила Юникода.

Более подробно о каждом из модификаторов смотри далее. Скорее всего вым не
нужно знать эти детали для C</l>, C</u> и С</d> и можете пропустить вперед
 L<E<sol>a|/E<sol>a (и E<sol>aa)>.

=head4 /l

используется для правил текущей локали  (см. L<perllocale>) когда шаблон найден. 
Например C<\w> будет совпадать с символами "слова" текущей локали 
и C<"/i"> регистронезависимый поиск будет искать согласно
текущим правилам регистронезависимого сравнения. Будет использоваться одна локаль
во время поиска по шаблону. Это может быть не
то же самое, как во время локали времени компиляции и поиск может отличаться один от другого
 если еще есть промежуточный вызов из
L<setlocale() function|perllocale/The setlocale function>.

Perl поддерживает только однобайтовые локали. Это означает, что код символа, который 
выше 255, рассматриваются как Юникод независимо от того, какая локаль действует.
Согласно правилам Юникода есть несколько локалей без учета регистра, которые пересекают границу
255/256 . Они запрещены при C</l>. Например,
0xFF (на ASCII платформах) не соответствует символу 0x178,C<LATIN CAPITAL LETTER Y WITH DIAERESIS>, в подшаблоне
, потому что 0xFF не может быть 
C<LATIN SMALL LETTER Y WITH DIAERESIS> в текущей локали, и Perl
не имеет возможности узнать даже существует ли этот символ в этой локали.

Этот модификатор можно определить, используя C<use locale>, но посмотрите
 L</Какой набор символьных модификаторов действует?>.
X</l>

=head4 /u

означает использования правил Unicode во время поиска по шаблону. На платформах ASCII
это означает, что символы с кодом от 128 до 255 такие, как 
Latin-1 (ISO-8859-1) значения (которые такие же, как в Юникоде).
(Иначе Perl считает, что их значение будет неопределенным). Таким образом,
под этот модификатором платформа ASCII фактически становится Юникодной
платформой; и следовательно, к примеру, C<\w> будет соответствовать любому из более чем
100_000 буквенных символов в Юникоде.

В отличие от большинства локалей, которые являются специфическими для пары язык-страна,
Юникод классифицирует все символы, как символ для письма, которые используются I<где угодно>
в мире, как C<\w>. Например, ваша локаль может не считать C<LATIN SMALL
LETTER ETH> как строковый символ (пока вы не будете говорить на исландском), а Юникод принимает этот символ за строчный. Аналогичным образом все символы, десятичные цифры
 везде в мире будут соответствовать C<\d>; это сотни, а не 10-ки
возможных совпадений. И некоторые из этих цифр выглядят, как некоторые из 10
ASCII цифр, но означают другое число, поэтому человек легко может думать, что это
совсем другое число, чем на самом деле. Например,
C<BENGALI DIGIT FOUR> (U+09EA)  выглядит очень похоже на
C<ASCII DIGIT EIGHT> (U+0038). И C<\d+> может найти символы , которые могут соответствовать символам цифр,
 котрые представляют собой смесь из различных систем письма, созданных из соображений безопасности. 
 L<Unicode::UCD/num()> может использоваться для сортировки. 
 А модификатор C</a> может использоваться для принудительного поиска шаблоном C<\d>  
только ASCII цифр от 0 до 9.
 
Кроме того под этим модификатором, регистронезависимый поиск символов работает на полном
наборе Юникодных символов. C<KELVIN SIGN>, например совпадает с буквами "k" и
"K"; и  C<LATIN SMALL LIGATURE FF> соответствует последовательности "ff", которая,
если вы не подготовлены, может выглядеть, как шестнадцатеричная константа,
что представляет еще одну потенциальную проблему безопасности. См.
L<http://unicode.org/reports/tr36> для подробного обсуждения 
вопросов безопасности в Юникоде.

Этот модификатор может определяться по умолчанию, используя C<use feature
'unicode_strings>,  C<use locale ':not_characters'>, или
C<L<use 5.012|perlfunc/use VERSION>>>> (или выше),
но посмотрите главу L</Какой набор символьных модификаторов действует?>.
X</u>

=head4 /d

Этот модификатор означает использование собственные правила платформы "По умолчанию",
за исключением случаев, когда вместо этого есть основания для использования правил Юникода, следующим образом:

=over 4

=item 1

целевая строка кодируется в UTF-8; или

=item 2

шаблон кодируется в UTF-8; или

=item 3

шаблон явно упоминает код символа, который находится выше 255 (скажем
C<\x{100}>); или

=item 4

шаблон использует Юникодное имя (C<\N{...}>);  или

=item 5

шаблон использует Юникодное свойство (C<\p{...}>); или

=item 6

шаблон использует L</C<(?[ ])>>

=back

Другая мнемоникак для этого модификатора "Зависит от", и правила, которые на самом деле
используются зависят от различных вещей, и в результате вы можете получить неожиданные
результаты. Смотрите L<perlunicode/"<Bug Юникода">.  Ошибка Unicode 
становиться довольно печальной, ведущих к еще одному (версия для печати) имени для этого
модификатора, "Dodgy" "Непредсказуемый" или "Рисковый".

Если шаблон или строки не кодируются в UTF-8, то буду найдены только символы ASCII.

Вот некоторые примеры того, как это работает на ASCII платформе:

 $str =  "\xDF";      # $str не в UTF-8 формате.
 $str =~ /^\w/;       # Не найдет, так как $str не в UTF-8 формате.
 $str .= "\x{0e0b}";  # Теперь строка $str в UTF-8 формате.
 $str =~ /^\w/;       # Найдет! $str теперь в UTF-8 формате.
 chop $str;
 $str =~ /^\w/;       # Все еще найдет! $str остается в UTF-8 формате.

Этот модификатор автоматически выбирается по умолчанию, если ни один другой не указан
, таким образом для него другое имя — "По умолчанию" ("Default").

Из-за неожиданного поведения, связанные с этим модификатором, вам
вероятно следует его использовать только, его вам нужно сохранить странные обратные совместимости.

=head4 /a (и /aa)

Этот модификатор выступает за ASCII строгость  (или ASCII-безопасность). Этот модификатор,
в отличие от других, может в два раза расширить свой эффект.

Когда он появляется один, то он применяется к последовательности  C<\d>, C<\s>, C<\w>, и
классам символов Posix для соответствия только в диапазоне ASCII.
Они, таким образом, возвращаются к версиям до 5.6 (pre-5.6), бывшим еще до значений Юникода (pre-Unicode).
Под модификатором C</a>,  C<\d>
всегда означает точко цифры от C<"0"> до C<"9">; C<\s> означает пять символов
 C<[ \f\n\r\t]>, и начиная с Perl v5.18, экспериментально,
 вертикальный табулятор; C<\w> означает 63 символа
C<[A-Za-z0-9_]>; кроме того, все Posix классы такие как 
C<[[:print:]]> найдут только соответствующие символы ASCII-диапазона.

Этот модификатор является полезным для людей, которые только изреда используют Юникод,
и, которые не желают обременяться его сложностью и проблемами безопасности.

С модификатором C</a>, вы можете написать C<\d> с уверенностью, что он точно найдет только
ASCII символы, и, если вам нужно найти что-то за пределами сиволов ASCII, вы можете 
вместо этого использовать C<\p{Digit}> (или C<\p{Word}> для C<\w>).  
Есть аналогичные конструкции C<\p{...}> , которые могут соответствовать симолам за пределами ASCII 
как для пробельных символов (см.  L<perlrecharclass/Whitespace>) , так и для классов Posix (см.
L<perlrecharclass/POSIX Character Classes>.
Таким образом этот модификатор не означает, что вы не можете использовать Unicode, 
это означает, что для поиска Юникодных символов вы должны явно использовать конструкцию (C<\p{}>, C<\P{}>),
 которая говорит о том, что это Юникод.

Как и следовало ожидать, этот модификатор вызывает, например, что C<\D> означает то же, что и
C<[^0-9]>; в самом деле все не ASCII находят
C<\D>, C<\S>, и C<\W>.  C<\b> по-прежнему соответствует границе
между C<\w> и C<\W>, используя свое определение при модификаторе C</a> (аналогично
для C<\B>).

В противном случае C</a> ведет себя как модификатор C</u> , в 
регистронезависимом поиске семантики Юникодных символов; к примеру будет "k"
найдет юникодный C<\N{KELVIN SIGN}> при поиске с модификатором C</i>  и код
символов в диапазоне Latin1, выше ASCII будет иметь правила Юникода, как они действуют
 при поиске без учета регистра.

Для запрещения поиска ASCII/не-ASCII (например, как "k" с C<\N{KELVIN SIGN}>),
поставьте "a" дважды, например C</aai> или C</aia>.  (Первой появление
 "a" ограничивает C<\d>, и так далее, а второе появление
 добавляет ограничение для C</i>.) Но, нужно заметить, что для символов вне 
 диапазона
ASCII будет использоваться правила Юникода для C</i> поиска, таким образом, модификатор,
 в действительности, не ограничивает символы только ASCII диапазоном; он просто запрещает
смешение символов ASCII и не ASCII диапазона.

Подводя итог, этот модификатор обеспечивает защиту для приложений, которые
 не хотят быть подвержены влиянию Юникода. Указав его дважды
  вы получаете дополнительную защиту.

Этот модификатор может бытьуказан по-умолчанию с помощью C<use re '/a'>
или C<use re '/aa'>.  Если вы так сделаете, вы можете иметь возможность использовать модификатор
C</u> явно, если существует несколько регулярных выражений,
где вы хотите использовать полные правила Юникода
(но даже здесь, лучше, если бы работала функция 
 C<"unicode_strings">, наряду с
C<use re '/aa'>).  Также смотри L</Какой набор символьных модификаторов действует?>.
X</a>
X</aa>

=head4 Какой набор символьных модификаторов действует?

Какой набор символьных модификаторов действует
в любой месте регулярного выражения зависит от набора довольно сложных взаимодействий.
Они разработаны таким образом, что в целом вам не придется беспокоиться об этом, но
этот раздел даст вам кровавые подробности.
Как объясняется ниже в L</Расширенных шаблонах> это возможно явно
указав модификаторы, которые применяются только к части регулярного выражения.
Внутреннее всегда имеет приоритет над любым внешним и одно применение
для целого выражения имеет приоритет над любым из параметров по умолчанию,
описанному в оставшейся части этого раздела.

Прагма C<L<use re 'E<sol>foo'|re/"'/flags' mode">> может использоваться для установки модификаторов 
по умолчанию (включая эти) для скомпилированных регулярных выражений
в пределах своей области.  Эта прагма имеет приоритет над другими прагмами,
перечисленные ниже, что также изменяет значения по умолчанию.

Иначе, C<L<use locale|perllocale>> устанавливает модификатор по умолчанию в C</l>;
и C<L<use feature 'unicode_strings|feature>>, или
C<L<use 5.012|perlfunc/use VERSION>> (или выше) установка умолчания в
C</u> когда не в той же области, либо как C<L<use locale|perllocale>>
или C<L<use bytes|bytes>>.
(C<L<use locale ':not_characters'|perllocale/Unicode and UTF-8>> также
устанавливают умолчание в C</u>, переопределяет и простой C<use locale>.)
В отличие от механизмов, упомянутых выше, эти
операнды влияют на операции помимо поиска регулярного выражения по шаблону  и поэтому
дают более последовательные результаты с другими операторами, в том числе с использованием
C<\U>, C<\l> и т.д. в операциях замены.

Если ни один из перечисленных выше вариантов не применяется, то, для обратной совместимости
модификатор C</d> является в сущности по умолчанию. Так как это может привести к
неожиданным результатам, то лучше указать какой другой набор правил должен 
использоваться.

=head4 Модификатор поведения набора символов до Perl 5.14

До 5.14, были не было явных модификаторов, но C</l> подразумевается
для регулярных выражений, скомпилированные в соупе  C<use locale> и C</d> 
подразумевался иначе.Однако интерполяция регексов в больших регексах
будет игнорировать оригинальную компиляцию в пользу всего, что было в действительности
во время второй компиляции. Существует ряд несоответствий (ошибок) 
с модификатором C</d> , где правила Юникода
будут неуместны и наоборот.C <\p{}> не подразумевает
правил Юникода и не делает все вхождения C<\N{}>, до 5.12.

=head2 Регулярные выражения

=head3 Метасимволы

Шаблоны, используемые в Perl эволюционировали от тех, 
которые были в Процедурах Регулярных Выражениях Версии 8 (Version 8 regex routines).
Процедуры являются производными (отдаленно) 
от свободно распространяемой повторной реализации подпрограмм версии V8 Генри Спенсера .
См. L<Версия 8 Регулярных Выражений> для подробностей.

В частности следующие метасимволы имеют значения по I<egrep>-ному стандарту:
X<метасимволы>
X<\> X<^> X<.> X<$> X<|> X<(> X<()> X<[> X<[]>


    \        Экранирование следующего метасимвола
    ^        Найдет начало строки
    .        Найдет любой символ (кроме символа новой строки)
    $        Найдет конец строки (перед символом новой строки в конце)
    |        Альтернатива
    ()       Группировка
    []       Класс символов в квадратных скобках

По умолчанию, символ "^" гарантирует, что найдется только начало строки
, а символ "$" найдет только конец (или перед символом новой строки в конце
), и Perl делает определенные оптимизации, предполагая, что набор символов содержит только одну строку.
Внутренние новые строки не будут найдены "^" или "$".  Вы можете, тем не менне пожелать
представить символы для поиска как буфер из многих строк, тогда "^" будет найдет после любого символа новой строки внтури символов для поиска (исключанием является случай, когда 
символ новой строки является последним символом в строке поиска), 
и "$" найдет перед любым символом новой строки. Стоимость накладных 
расходов немного больше, если вы применяете к шаблону поиска модификатор /m.
(Старые программы делали это, устанавливая C<$*>,
но эта возможность удалена в perl 5.10.)
X<^> X<$> X</m>

Для упрощения замены в многострочном буфере, символ "." никогда не найдет
 символ новой строки, только, если вы не используете модификатор C</s>, который фактически сообщает Perl,
  что весь буфер для поиска - это одна строка --даже если это не так.
X<.> X</s>

=head3 Повторители (Квантификаторы, умножители, символы, указывающие количество)

Существуют следующие стандартные повторители:
X<метасимвол> X<повторитель> X<*> X<+> X<?> X<{n}> X<{n,}> X<{n,m}>

    *           Найдет 0 или больше раз
    +           Найдет 1 или больше раз
    ?           Найдет 1 или 0 раз
    {n}         Найдет точно n раз
    {n,}        Найдет по крайней мере n раз
    {n,m}       Найдет по крайней мере n раз, но не более m раз

(Если фигурная скобка находится в любом другом контексте и не являются частью
эскейп последовательности такой, как  C<\x{...}>, то она обрабатывается как обычный
символ. В частности, нижняя граница повторителя не является обязательной,
опечатка в повторителе молча рассматривает его, как
буквенные символы. Например,

    /o{4,3}/

выглядит как повторитель, который найдется 0 раз, так как 4 больше 3,
но это в действительности это означает соответствие последовательности из шести символов
S<C<"o { 4 , 3 }">>.  
Запланировано в конечном счете потребовать буквального использования
из фигурных скобок, которых будут заэкранированы, скажите, поставив перед ними обратную косую черту
или поставив их квадратные скобоки,
, (C<"\{"> или C<"[{]">).  
Это изменение будет допускать будущее расширения синтаксиса (как создание нижней границы
повторителя, как опциональное), и лучшей проверки на ошибки. Тем временем 
вы должны привыкнуть избегать всех случаев, где
вы имеете в виду чимвол "{".)

Повторитель "*" означает тоже, что и C<{0,}>, повторитель "+"
это C<{1,}>, и "?" это C<{0,1}>.  n и m ограничены
неотрицательными значениями меньше, чем заданный предел, определенный во время сборки perl.
Это обычно 32766 на наиболее распространенных платформах. Фактический предел может
будьте найден в сообщении об ошибке, произведенном следующим кодом:

    $_ **= $_ , / {$_} / for 2 .. 42;

По умоланию повторительный подшаблон "жадный", это означает, что он будет искать
максимальное число совпадений из возможного (наиная с указанной стартовой позиции)
пока еще соответствие шаблону остается.  Если вы хотите найти минимальное число совпадений
, укажите после повторителя "?".  Следует что значение шаблона не меняется,
а только его "жадность":
X<метасимвол> X<жадный> X<жадность>
X<?> X<*?> X<+?> X<??> X<{n}?> X<{n,}?> X<{n,m}?>

    *?        Найдёт 0 или больше раз, не жаден
    +?        Найдёт 1 или больше раз, не жаден
    ??        Найдёт 0 или 1 раз, не жаден
    {n}?      Найдёт точно n раз, не жаден (излишне)
    {n,}?     Найдёт как минимум n раз, не жаден
    {n,m}?    Найдёт как минимум n раз но не более m раз, не жаден

По умолчанию, когда повторенный вложенный шаблон не позволяет совпасть остальной части
общего шаблона, Perl делает шаг назад (backtrack). Однако такое поведение является
иногда нежелательно. Тогда Perl предоставляет форму "притяжательного" повторителя.

 *+     Найдёт 0 или больше раз и не дает возврата
 ++     Найдёт 1 или больше раз и не дает возврата
 ?+     Найдёт 0 или 1 раз и не дает возврата
 {n}+   Найдёт точно n раз и не дает возврата (излишне)
 {n,}+  Найдёт как минимум n раз и не дает возврата
 {n,m}+ Найдёт как минимум n раз но не более m раз и не дает возврата

Например,

   'aaaa' =~ /a++a/

никогда не найдется, так как C<a++> будет съедать все C<a> в
строке и не оставит ни одного символа для оставшейся части шаблона. 
Эта особенность может быть экстремально полезна, давая перлу сигнал, 
где не должно быть возврата назад. Например, типичная проблема "поиска строки в двойных кавычках"
 может решиться наиболее эффективно, когда написано так:

   /"(?:[^"\\]++|\\.)*+"/

как мы знаем, если последняя кавычка не находится, то поиск с возвратом не поможет.

Смотри независимое выражение
L</C<< (?>pattern) >>> для деталей;
притяжательные повторители являются только синтаксическим сахаром для этой конструкции. Например, 
пример, приведенный выше, может быть записан следующим образом:

   /"(?>(?:(?>[^"\\]+)|\\.)*)"/

=head3 Эскейп последовательности (или последовательности обратной косой черты)

Поскольку шаблоны обрабатываются, как строки в двойных кавычках, то следующие
последовательности также будут работать:

 \t          табуляция                   (HT, TAB)
 \n          новая строка               (LF, NL)
 \r          ввод, перенос строки                (CR)
 \f          Перевод формата (Formfeed)             (FF)
 \a          Тревога (звуковой сигнал)          (BEL)
 \e          Клавиша ESC (Escape) (think troff)  (ESC)
 \cK         символ control          (пример: VT)
 \x{}, \x00  порядковый номер символа, данный в шестнадцатиричном формате
 \N{name}    Именованный символ Юникода или последовательность символов
 \N{U+263D}  Юникодный символ     (пример: FIRST QUARTER MOON)
 \o{}, \000  порядковый номер символа, данный в восьмеричном формате
 \l          Следующий символ в нижнем регистре (думая vi)
 \u          Следующий символ в верхнем регистре (думая vi)
 \L          Нижний регистр до \E (думая vi)
 \U          Верхний регистр до \E (думая vi)
 \Q          (quote) Отключает действие метасиволов в шаблоне до \E
 \E          Завершение модификации, конец случае модификации или заквотированной секции, думая vi

Подробнее смотри L<perlop/"Квотирование и Операторы заключения в кавычки"> (L<perlop/Quote and Quote-like Operators>).

=head3 Символьные типы и другие специальные эскейп символы

Кроме того Perl определяет следующее:
X<\g> X<\k> X<\K> X<backreference>

 Последовательность   Замечание    Описание
  [...]     [1]  Найдет символ, который соответствует правилу в квадратных скобках,
                 определенный "...".
                   Например: [a-z] найдет "a" или "b" или "c" ... или "z"
  [[:...:]] [2]  Найдет символ, который соответствует правилам POSIX
                    "..." класса символов в двойных квадратных скобках. Например: [[:upper:]] найдет любой 
                    символ в верхнем регистре.
  (?[...])  [8]  Расширенный класс символоd в скобках
  \w        [3]  Найдет символ "слова" (буквацифра плюс "_", плюс
                  другие соединительные знаки пунктуации, отметки Юникода)
  \W        [3]  Найдет символ не-"слова"
  \s        [3]  Найдет пробельный символ
  \S        [3]  Найдет не пробельный символ
  \d        [3]  Найдет символ десятичной цифры
  \D        [3]  Найдет отрицание символа десятичной цифры
  \pP       [3]  Найдет P, именованное свойство. Ипользуйте \p{Prop} для длинных имен
  \PP       [3]  Найдет не-P
  \X        [4]  Найдет Юникодный "расширенный графема кластер"
  \C             Найдет один символ из языка C (октет - 8 битб 1 байт) даже, если он часть
                   большого UTF-8 символа.  Таким образом он ломает символы в их байты из UTF-8, так что вы можете 
                   получить искаженные кусочки(malformed pieces) UTF-8.
                   Не поддерживается в поиске вперед.
  \1        [5]  Обратная ссылка на конкретную группу или буфер.
                   '1' на самом деле может быть любое положительное целое число.
  \g1       [5]  Обратная ссылка на конкретную или предыдущую группу,
  \g{-1}    [5]  Числа могут быть отрицательными, указывать относительно
                  предыдущей группы и при необходимости могут быть обернуты в
                  фигурные скобки для безопасного синтаксического разбора.
  \g{name}  [5]  Именованная обратная ссылка
  \k<name>  [5]  Именованная обратная ссылка
  \K        [6]  Сохраняет найденный материал слева от \K, не включая его в $&
  \N        [7]  Любой символ, кроме \n.  Не влияет на модификатор /s
  \v        [3]  Вертикальный пробел
  \V        [3]  Невертикальный пробел
  \h        [3]  Горизонтальный пробел
  \H        [3]  Негоризонтальный пробел
  \R        [4]  Универсальная новая строка

=over 4

=item [1]

См. L<perlrecharclass/Bracketed Character Classes> для деталей.

=item [2]

См. L<perlrecharclass/POSIX Character Classes> для деталей.

=item [3]

См. L<perlrecharclass/Backslash sequences> для деталей.

=item [4]

См. L<perlrebackslash/Misc> для деталей.

=item [5]

См. L</Группы захвата> ниже для деталей.

=item [6]

См. L</Расширенные шаблоны поиска> ниже для деталей.

=item [7]

Обратите внимание, что C<\N> имеет два значения. Когда он в форме C<\N{NAME}>, он соответствует
символу или последовательности символов, которые называются C<NAME>; и так же,
когда форма C<\N{U+I<hex>}>, она соответствует символу Юникода, в шестнадцатиричном коде
— <hex>. В противном случае он соответствует любому символу, кроме C<\n>.

=item [8]

See L<perlrecharclass/Расширенная классы скобочных символов (Extended Bracketed Character Classes)> для деталей.

=back

=head3 Утверждения

Perl определяет следующие утверждения нулевой длины:
X<утверждения нулевой длины> X<утверждения> X<регексы, утверждения нулевой длины>
X<регекспы, утверждения нулевой длины>
X<регулярные выражения, утверждения нулевой длины>
X<\b> X<\B> X<\A> X<\Z> X<\z> X<\G>

    \b  Найдет границу слова
    \B  Найдет все, кроме границы слова
    \A  Найдет начало строки
    \Z  Найдет только в конце строки или перед новой строкой в конце
    \z  Найдет только в конце строки
    \G  Найдет только в pos() (т.е. в конце последней найденной позиции m//g)

Граница слова (C<\b>) это место между двумя символами,
которые содержат C<\w> на одной их стороне и  C<\W> на другой
 (в любом порядке), считая воображаемые символы начала и конца строки, как C<\W>.
  (Внутри сивольных классов C<\b> 
  представляет клавишу backspace, а не границу слова,так, как это обычно бывает в любой строке в двойных кавычках.)
C<\A> и C<\Z> работают также, как и "^" и "$", за исключением того, что они
не будут искать несколько раз, когда используется модификатор C</m>
, тогда как
"^" и "$" будут соответствовать каждой внутренней линии границы. 
Чтобы найти актуальный конец строки и не игнорировать 
дополнительные конечные строки, используйте C<\z>.
X<\b> X<\A> X<\Z> X<\z> X</m>

Утверждение C<\G> можно использовать для глобального поиска (используя
C<m//g>), как описано в L<perlop/"Квотирование и Операторы заключения в кавычки"> (L<perlop/Quote and Quote-like Operators>).
Это также удобно во время написания C<lex>-подобных сканнеров, когда у вас есть несколько паттернов,
 которым вы хотите сопоставить последующие подстроки строки;
 cмотрите предыдущие ссылки. 
 Фактическое местонахождение, где C<\G> будет находить, 
 также может определяться с помощью C<pos()> как lvalue(левое значение): см. L<perlfunc/pos>.
 Обратите внимание, что правило нулевой длины
 (см.  L</"Повторяющиеся шаблоны, находящие подстроки нулевой длины">
 (L</"Repeated Patterns Matching a Zero-length Substring">))
изменяется несколько в том, что содержимое слева от C<\G>
не учитываются при определении длины найденного. Таким образом следующее
никогда не будет соответствовать:
X<\G>

     my $string = 'ABC';
     pos($string) = 1;
     while ($string =~ /(.\G)/g) {
         print $1;
     }

Он напечатет 'A' и остановиться, т.к. будет считаться, что был поиск
 нулевой ширины и таким образом - он не будет соответствовать одной и той же позиции дважды в
строке.

Стоит отметить, что C<\G> при не правильном использовании может привести к бесконечному
циклу. Будьте осторожны при использовании шаблонов, которые включают C<\G> как альтернативу.

=head3 Группы захвата

Скобочная конструкция C<( ... )> создаёт группы захвата (также именуется как
буферы захвата). Чтобы сослаться на текущее содержимое группы позже в пределах
текущего шаблона поиска нужно использовать C<\g1> (или C<\g{1}>) для первой, C<\g2> (или C<\g{2}>)
для второй группы и так далее.
Это называется I<обратной ссылкой> (I<backreference>).
X<регекс, буфер захвата> X<регексп, буфер захвата>
X<регекс, группа захвата> X<регексп, группа захвата>
X<регулярное выражение, буфер захвата> X<обратная ссылка>
X<регулярное выражение, группа захвата> X<backreference>
X<\g{1}> X<\g{-1}> X<\g{name}> X<относительная обратная ссылка> X<именованная обратная ссылка>
X<именованный буфер захвата> X<регулярное выражение, именованный буфер захвата>
X<именованная группа захвата> X<регулярное выражение, именованная группа захвата>

X<regex, capture buffer> X<regexp, capture buffer>
X<regex, capture group> X<regexp, capture group>
X<regular expression, capture buffer> X<backreference>
X<regular expression, capture group> X<backreference>
X<\g{1}> X<\g{-1}> X<\g{name}> X<relative backreference> X<named backreference>
X<named capture buffer> X<regular expression, named capture buffer>
X<named capture group> X<regular expression, named capture group>
X<%+> X<$+{name}> X<< \k<name> >>
Количество захваченных подстрок, которые вы можете использовать не ограничено.
Группы нумеруются с левой открывающей круглой скобки номер 1, и т.д. Если
группа не найдена, связанные обратные ссылки тоже не будут совпадать. (Это
может случиться, если группа не является обязательной, или поиск идет в альтернативной ветке).
Вы можете опустить C<"g"> и написать C<"\1">, и т.д., но с этим есть некоторые проблемы, описанные ниже.

Также можно захватывать группы относительно друг друга, используя отрицательное число, так 
С<\g-1> и С<\g{-1}> оба относятся к группе непосредственно перед захватом и 
C<\g-2> и C<\g{-2}> относятся к группе перед ней. Например:

        /
         (Y)            # группа 1
         (              # группа 2
            (X)         # группа 3
            \g{-1}      # обратная ссылка на группу 3
            \g{-3}      # обратная ссылка на группу 1
         )
        /x

поиск будет таким же, как C</(Y) ( (X) \g3 \g1 )/x>. Это позволяет
интерполировать регулярные выражения в большие регулярные выражения
и тогда не придется беспокоиться о перенумерации групп захвата.

Можно вообще обойтись числами и создать именованные группы захвата.
Нужно объявить C<(?E<lt>I<name>E<gt>...)> и C<\g{I<name>}> для такой
ссылки. (Чтобы быть совместимым с регулярные выражения .Net, C<\g{I<name>}> 
также может быть написано как C<\k{I<name>}>,  C<\kE<lt>I<name>E<gt>> или C<\k'I<name>'>.)
I<name> не должно начинаться с цифры или содержать дефисы.
Если несколько групп в рамках шаблона имеют одинаковое имя, то любая ссылка
 на это имя подразумевает самую левую определяемую группу. Именованные группы уичтываются и в
абсолютной и в относительной нумерации и на них также можно сослаться с помощью номера.

(Это делает возможным делать вещи с именованными группами захвата, которые бы в противном случае
требовали бы C<(??{})>.)

Cодержимое захваченной группы определяется динамически и оно доступно для вас вне
 шаблона поиска до конца закрывающего блока или до следующего успешного
поиска, что наступит раньше. (См. L<perlsyn/"Составные операторы">.)
Вы можете обращаться к ним по абсолютному номеру (используя C<"$1"> вместо C<"\g1">,
и т.д.); или по имени через хэш  C<%+>, с помощью C<"$+{I<name>}">.

Скобки требуются для ссылки на именованные группы захвата, но являются опциональными для
абсолютной или относительной нумерации групп. Скобки являются более безопасными, когда созданется регулярное выражение
объединение меньших строк. Например, если у вас есть C<qr/$a$b/> и C<$a>
содержит C<"\g1">, и  C<$b>  содержит C<"37">, вы получите C</\g137/>, что является, вероятно, не тем,
 что вы хотели.

Обозначения C<\g> иC<\k> были введены в Perl 5.10.0. До этого
не было ни именованных, ни относительно пронумерованных групп захвата. Абсолютная нумерация
группы передавалась с помощью C<\1>,
C<\2> и т.д., и эта запись до сих пор
принимается (и скорее всего всегда будет). Но это приводит к некоторым неясностям, если
есть более чем 9 групп захвата, так C<\10> может означать либо десятую
группу захвата, или символ, чей порядковый номер восьмеричное-010 (бэкспейс (пробел назад) в
ASCII). Perl разрешает эту неопределенность путем интерпретации  C<\10> как обратной ссылки
только, если по крайней мере 10 левых скобок были открыты перед ней. Аналогичным образом, C<\11>
 - это обратная ссылка только, если по крайней мере 11 левых скобок открыты перед ней.
И так далее. От C<\1> до C<\9> всегда интерпретируются как обратные ссылки.
Есть несколько примеров ниже, которые иллюстрируют эти риски. Вы можете избежать
двусмысленности всегда используя C<\g{}> или C<\g>, если вы имеете в виду захватываемые группы;
и для восьмеричных констант всегда использовать C<\o{}>, или для C<\077> и ниже, используя 3
цифры с ведущими нулями, поскольку лидирующий ноль означает восьмеричную
константу.

Обозначения C<\I<digit>> также работает в определенных обстоятельствах за пределами
шаблона. Смотри  L</Предупреждение на \1 вместо $1> ниже для деталей.

Examples:

    s/^([^ ]*) *([^ ]*)/$2 $1/;     # поменять местами первые два слова

    /(.)\g1/                        # найдет первый дублирующий символ
         and print "'$1' is the first doubled character\n";

    /(?<char>.)\k<char>/            # ... другой способ
         and print "'$+{char}' is the first doubled character\n";

    /(?'char'.)\g1/                 # ... смешанный поиск
         and print "'$1' is the first doubled character\n";

    if (/Time: (..):(..):(..)/) {   # разобрать значения
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }

    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/   # \g10 - это обратная ссылка
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/    # \10 - восьмеричное число
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/  # \10 - это обратная ссылка
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 - восьмеричное число

    $a = '(.)\1';        # Создает проблемы, когда объединяются.
    $b = '(.)\g{1}';     # Позволяет избежать проблем.
    "aa" =~ /${a}/;      # Правда
    "aa" =~ /${b}/;      # Правда
    "aa0" =~ /${a}0/;    # Ложь!
    "aa0" =~ /${b}0/;    # Правда
    "aa\x08" =~ /${a}0/;  # Правда!
    "aa\x08" =~ /${b}0/;  # Ложь

Несколько специальных переменных также вернут порцию предыдущего поиска.
 C<$+> вернет результат найденного в последней скобке.
C<$&> вернет всю совпадающую строку. (Раньше это делал  C<$0>,
 но теперь он возвращает имя программы.) C<$`> вернет 
все перед совпавшей строкой.C<$'> вернет все
после совпавшей строки. И C<$^N> содержит все, что было найдено 
в самой недавно закрытой группе (подстроку). C<$^N> может быть использован в
расширенные шаблонах (см. ниже), например назначить найденную подстроку 
переменной.
X<$+> X<$^N> X<$&> X<$`> X<$'>

Существуют специальные переменные такие как хеш C<%+> и пронумерованные переменные поиска
(C<$1>, C<$2>, C<$3>, и т.д.) динамически распространяющиеся 
до конца закрывающего блока или до следующего успешного поиска,
 что наступит раньше.  (См. L<perlsyn/"Составные операторы">.) (См. L<perlsyn/"Compound Statements">.)
X<$+> X<$^N> X<$&> X<$`> X<$'>
X<$1> X<$2> X<$3> X<$4> X<$5> X<$6> X<$7> X<$8> X<$9>

B<ЗАМЕЧАНИЕ>: неудачные поиски в Perl не сбрасывают переменные поиска,
что упрощает написание кода, который проверяет серию
конкретных случаев и запоминает лучший поиск.

B<ПРЕДУПРЕЖДЕНИЕ>: как только Perl видит, что вам нужна одна из переменных 
C<$&>, C<$`>, или C<$'> где-либо в программе, он должен предоставить их для каждого
поиска по шаблону. Это может существенно замедлить вашу программу. Perl
использует тот же механизм для производства  C<$1>, C<$2>, и т.д., так, что вы также платите
существенную цену для каждого шаблона, который содержит захватывающие скобки. (Чтобы
избежать этой платы при сохранении группирующего поведения, используйте
вместо этого расширенное регулярное выражение C<(?: ... )> .) Но если вы никогда не
используете  C<$&>, C<$`> или C<$'>, тогда шаблоны I<без> захватывающих
скобок не будут наказаны. Поэтому избегайтеC<$&>, C<$'>, или C<$`>,
если можете, но если вы не можете (и я очень ценю некоторые такие алгоритмы),
 после того как вы использовали их один раз, использовать их по своему желанию, потому что вы
уже за низ заплатили. По состоянию на 5.17.4, присутствие каждой из трех
переменных в программе регистрируется отдельно и, в зависимости от
обстоятельства, perl может быть в состоянии быть более эффективным зная что только  C<$&>
, а не все три будут использованы, например.
X<$&> X<$`> X<$'>

Для того, чтобы обойти эту проблему Perl 5.10.0 представляет переменные  C<${^PREMATCH}>,
C<${^MATCH}> иC<${^POSTMATCH}>, которые эквивалентны  C<$`>, C<$&>
и C<$'>, B<исключая> то, что только они будут гарантированно определены после
успешного поиска, который был выполнен с модификатором C</p> (preserve) (сохранять) .
Использование этих переменных не влечет к штрафу глобальной производительности, в отличие от
их эквивалента в виде знаков препинания, однако здесь вы идете на компромисс того, что вы
должны сказать perl, когда вы хотите их использовать.
X</p> X <p модификатор>

=head2 Квотирующие метасимволы (Quoting metacharacters)

Метасимволы с обратным слэшем в Perl являются буквенно-цифровыми, например C<\b>,
C<\w>, C<\n>. В отличие от некоторых других языков с регулярными выражениями, не существует
символов с обратным слэшем, которые не являются буквенно-цифровыми. Так что все, что
  выглядит как \\, \(, \), \ [, \], \ {, или \} всегда
интерпретируется как буквенный символ, а не метасимвол. Это было
некогда общей идеей для отключения или квотирования (оборачивание в кавычки) метасимволов, имеющих специальное значение
 в регулярных выражениях, которых вы хотите
использовать для шаблоне поиска. Теперь заквотируем (поставим обратный слэш) для всех не-"словесных" символов:

    $pattern =~ s/(\W)/\\$1/g;

(Если установлено C<use locale>, то это зависит от текущей локали.)
Сегодня чаще используют функцию quotemeta() или С<\Q>
метаквотированный эскейп символ для отключения специальных
значений всех метасимволов следующим образом:

    /$unquoted\Q$quoted\E$unquoted/

Учтите, что если вы положите символ косой черты (который не внутри
переменных с интерполяцией) между C<\Q> и C<\E>, двойное квотирование
интерполяции обратной косой черты может привести к нежелательным результатам. Если вам
I<нужно> использовать символ косой черты в пределах C<\Q...\E>,
проконсультируйтесь с (L<perlop/"Кровавые подробности разбора закавыченных(квотированных) конструкций">) (L<perlop/"Gory details of parsing quoted constructs">).

C<quotemeta()> и C<\Q> полностью описаны в L<perlfunc/quotemeta>.

=head2 Расширенные шаблоны

Perl также определяет синтаксис последовательного расширения функций не
 входящих в стандартные инструменты, такие как B<awk> и B<lex>. 
Синтаксис для большинства из них - это пара скобок с вопросительным знаком идущим сразу 
за первой скобкой. Символ идущий за вопросительным знаком указывает
расширение.

Стабильность этих расширений колеблется в широких пределах. Некоторые из них были
частью основного языка на протяжении многих лет. Другие экспериментальные
и могут меняться без предупреждения или быть полностью удалены. Проверяйте
документацию для каждого компонента для проверки его текущего
статуса.

Вопросительный знак был выбран для этого и для минимального соответствия
конструкции потому что 1) вопросительные знаки встречаются редко в старых регулярных
выражения и 2) всякий раз, когда вы его видите, вы должны остановиться и
"задаться вопросом" точности того, что происходит. Это психология...

=over 4

=item C<(?#text)>
X<(?#)>

Комментарий. Текст игнорируется. Если модификатор C</x>  позволяет
использование пробельных символов для форматирования, то простого C<#> будет достаточно. 
Обратите внимание, что Perl закрывает комментарий, как только он видит  C<)>, 
так что нет никакого способа положить литерал (символ)
C<)> в комментарий.

=item C<(?adlupimsx-imsx)>

=item C<(?^alupimsx)>
X<(?)> X<(?^)>

Один или несколько встроенных модификаторов в шаблон, чтобы быть включенным (или
выключенным, если предшествует C<->) на оставшуюся часть шаблона или
оставшуюся часть закрытой группы поиска(если таковые имеются).

Это особенно полезно для динамических шаблонов, например, которые читаются из
файла конфигурации, взяты из аргумента, или указаны в таблице
где-либо. Рассмотрим случай, когда некоторые шаблоны хотят быть
с учетом регистра,а другие нет: для того, чтобы поиска части шаблона был 
без учета регистра, то необходимо
включить C<(?i)> перед шаблоном. Например:

    $pattern = "foobar";
    if ( /$pattern/i ) { }

    # более гибко:

    $pattern = "(?i)foobar";
    if ( /$pattern/ ) { }

These modifiers are restored at the end of the enclosing group. For example,
Эти модификаторы восстанавливаются в конце внешней группы. Например,

    ( (?i) blah ) \s+ \g1

который найдет C<blah> в любом регистре, 
некоторые пробелы и точное (I<включая регистр>!)
повторение предыдущего слова, предполагая модификатор C</x>, а теперь нет модификатора C</i>
 за пределами этой группы.

Эти модификаторы не переносятся в именованные подмаски, вызванные в закрытой группе. 
Другими словами шаблон например C<((?i)(?&NAME))> не
измененяет чувствительности регистра для шаблона «"NAME".

Любой из этих модификаторов можно установить, что применить его
 глобально для всех регулярных выражений,
  скомпилированные в сфере  C<use re>. 
  См. L<re/"'/flags' mode">.

Начиная с Perl 5.14, C<"^"> (курсор или диакритический акцент) сразу за
 C<"?"> это сокращение соответствует C<d-imsx>.  Флаги (кроме
C<"d">) можгут следовать после курсора для переопределения.
Но минус не является легальным с ним.

Учтите, что модификаторы C<a>, C<d>, C<l>, C<p>, и C<u> являются специальными
 здесь они могут быть включены, не не выключены, а модификаторы C<a>, C<d>, C<l>, и
C<u> являются взаимоисключающими: указав один вы отрицаете другой,
 и максимум один из них (или два C<a>) может появится в этой конструкции.
 Таким образом, C<(?-p)> предупредит при компиляции при C<use warnings>;
C<(?-d:...)> и C<(?dl:...)> дадут фатальную ошибку.

Также, обратите внимание, что модификатор C<p> имеет особое значение в том, что его присутствие
в люом месте в шаблоне имеет глобальный эффект.

=item C<(?:pattern)>
X<(?:)>

=item C<(?adluimsx-imsx:pattern)>

=item C<(?^aluimsx:pattern)>
X<(?^:)>

Это для кластеризации, но не для захвата; он группирует подвыражения как
"()", но не делает обратной ссылки, как это делает "()". Так что

    @fields = split(/\b(?:a|b|c)\b/)

подобно

    @fields = split(/\b(a|b|c)\b/)

но не выплевывает дополнительные поля. Также дешевле не захватывать группы
, если вам не нужно.

Любые символы между C<?> и C<:> действуют как флаги модификаторов, такие как
C<(?adluimsx-imsx)>. Например,

    /(?s-i:more.*than).*million/i

эквивалентно более подробному

    /(?:(?s-i)more.*than).*million/i

Начиная с Perl 5.14, C<"^"> (курсор или диакритический акцент) сразу за
 C<"?"> это сокращение соответствует C<d-imsx>.  Любые позитивные флаги (кроме
C<"d">) можгут следовать после курсора, таким образом

    (?^x:foo)

эквивалентно

    (?x-ims:foo)

Курсор рассказывает Perl, что этот кластер не наследует флаги любых
окружающих шаблонов, но использует системные умолчания (C<d-imsx>),
измененные любыми указанными флагами.

Курсор позволяет упростить создание строчек (stringification) из скомпилированных регулярных
выражений. Они выглядят как

    (?^:pattern)

с любыми флагами не по умолчанию, появляющимися между курсором и двоеточием.
Тест, который выглядит, как перевод в строку (stringification), таким образом, не нуждается в 
в флагах по умолчанию, жестко зашитых в нем, только курсор. Если новые флаги
будут добавлены в Perl, смысл курсора расширения  изменится включением
флагов по умолчанию, поэтому тест все еще будет работать, без изменений.

Указание отрицательных флага, после курсора C<^>, является ошибкой, т.к. как флаг
 является излишним.
 
Мнемоника для C<(?^...)>: свежее начало, поскольку галка обычно используется для
поиска начала.

=item C<(?|pattern)>
X<(?|)> X<Branch reset>

Это "сброс ветки" шаблона, который имеет специальные свойства, 
когда захватываемые группы нумеруются с той же начальной точки
в каждой чередующейся ветке . Он доступен начиная с perl 5.10.0.

Группы захвата  нумеруются слева направо, но внутри этой
конструкции нумерация возобновляется для каждой ветви.

Нумерация в пределах каждой ветки будет нормальной и все группы
следующие за этой конструкцией будут пронумерованы так,как-будто бы конструкция
содержится только одну ветвь, ту, которая попадет в группу захвата.

Эта конструкция является полезной, когда вы хотите захватить одну из
 нескольких альтернативных групп.

Рассмотрим следующий шаблон. Цифры над под выражением
 показывают номера групп захвата.

    # before  ---------------branch-reset----------- after        
    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
    # 1            2         2  3        2     3     4  

Будьте внимательны при использовании сброса ветки шаблона в сочетании с
именем захвата. Именованные захваты реализованы как псевдонимы
нумерованным группам, что мешает
осуществлению сброса ветки шаблона. Если вы используете именованный захват
 в сбросе ветки шаблона, то лучше использовать те же имена,
в том же порядке, в каждом из альтернатив:

   /(?|  (?<a> x ) (?<b> y )
      |  (?<a> z ) (?<b> w )) /x

Не делайте так, это может привести к сюрпризам:

  "12" =~ /(?| (?<a> \d+ ) | (?<b> \D+))/x;
  say $+ {a};   # Prints '12'
  say $+ {b};   # *Also* prints '12'.

Проблема здесь в том, что обе группы назвали  C<< a >>, а группа с
именем C<< b >> является алиасом для группы, принадлежащей к  C<< $1 >>.

=item Утверждения Осмотра Вокруг (Look-Around Assertions)
X<утверждения окружения>X<look-around assertion> X<lookaround assertion> X<look-around> X<lookaround>

Утверждения Осмотра Вокруг представляют собой шаблоны нулевой ширины,
которые находя специфические элементы без включения результата в  C<$&>. 
Позитивные утверждения находяться, когда подмаски находятся,
отрицательные утверждения находятся, когда поиск по подмаске не удачный. 
Осмотр-До(look-behind) находит текст до текущей позиции,
Осмотр-После(look-ahead) находит текст следующий за позицией поиска.

=over 4

=item C<(?=pattern)>
X<(?=)> X<look-ahead, positive> X<lookahead, positive>

Позитивное нулевой ширины утверждение поиска вперед.  
Например, C</\w+(?=\t)/>
найдет слово, за которым следует табуляция
 без ключения таба в C<$&>.

=item C<(?!pattern)>
X<(?!)> X<look-ahead, negative> X<lookahead, negative>

Негативное нулевой ширины утверждение поиска вперед.  
Наприметр C</foo(?!bar)/>
найдет любое вхождение "foo" за которым не следует "bar". 
Замечание.
Однако поиск вперед и назад не то же самое. Вы не можете
использовать это для поиска назад.

Если вы ищете "bar" перед которым нет "foo", C</(?!foo)bar/>
, то будет искаться не то, что вы хотите.
Потому что C<(?!foo)> означает, что следующая вещь
 не может быть "foo"--но это не так, это "bar", таким образом "foobar" будет найден. 
 Используйте вместо этого поиск назад (смотрите ниже).

=item C<(?<=pattern)> C<\K>
X<(?<=)> X<look-behind, positive> X<lookbehind, positive> X<\K>

Позитивное нулевой ширины утверждение поиска назад.  
Например, C</(?<=\t)\w+/>
найдет слово, перед которым стоит таб, без включения таба в C<$&>.
Работает только для поиска назад фиксированной длины.

Существует специальная форма этой конструкции, называемая C<\K>, которая влияет на
регекс движок таким образом, что он "сохраняет" все, что было найдено перед C<\K>
и не включает это в C<$&>. Это обеспечивает эффективный поиск назад переменной длины.
Использования C<\K> внутри другого утверждения Осмотра Вокруг возможно, но это поведение
еще хорошо не определено.

Для различных причин C<\K> может быть значительно более эффективным, чем
эквивалентная конструкция C<< (?<=...) >> и он особенно полезен в
ситуации, где вы хотите эффективно удалить что-то следующее после строки. 
К примеру 

  s/(foo)bar/$1/g;

можно переписать гораздо более эффективно

  s/foo\Kbar//g;

=item C<(?<!pattern)>
X<(?<!)> X<look-behind, negative> X<lookbehind, negative>

Отрицающее утверждение нулевой ширины поиска назад.  
Например C</(?<!bar)foo/>
 найдет вхождения "foo" , которые не следуют за "bar".  Работает
только для поиска назад фиксированной длины.

=back

=item C<(?'NAME'pattern)>

=item C<< (?<NAME>pattern) >>
X<< (?<NAME>) >> X<(?'NAME')> X<named capture> X<capture>

Имя захваченной группы.
Идентично во всех отношениях для нормального захвата
скобками C<()>, но есть для дополнительной факт то, что к группе
можно обращаться по имени в различных конструкциях регулярных выражений
 (например, C<\g{NAME}>) и может быть доступен по имени
после успешного поиска через C<%+> или C<%->. См. L<perlvar>
для более подробной информации о хэшах C<%+> и C<%->.

Если несколько различных захватываемых групп  имеют одинаковые имена, то
$+{NAME} будет ссылаться на самую левую и этих групп.

Формы C<(?'NAME'pattern)> и C<< (?<NAME>pattern) >> эквивалентны.

B<ПРИМЕЧАНИЕ:> Хотя нотация этой конструкции такая же, как в регексах .NET , 
но поведение не совпадает. В Perl являются группы
нумеруются последовательно, независимо от того именованные они или нет. 
Таким образом, в шаблоне

  /(x)(?<foo>y)(z)/

$+{foo} будет тоже, что и $2, и $3 будет содержать 'z' 
вместо того, что хакер .NET регекса мог бы ожидать.

В настоящее время имя ограничивается простым идентификатором.
Другими словами, он должен совпадать с  C</^[_A-Za-z][_A-Za-z0-9]*\z/>  или
его Юникодным расширением (см. L<utf8>)
хотя он не поддерживает докали (locale) (см. L<perllocale>).

B<ПРИМЕЧАНИЕ:> для того, чтобы сделать вещи проще для программистов с опытом работы
с Python или движком регексов PCRE, шаблон C<< (?PE<lt>NAMEE<gt>pattern) >>
может быть использован вместо C<< (?<NAME>pattern) >>; Однако эта форма не
поддерживает использование одинарных кавычек в качестве разделителя для имени.

=item C<< \k<NAME> >>

=item C<< \k'NAME' >>

Именованная обратная ссылка. Похожа на цифровую обратную ссылку за исключением случаев
, когда группа обозначается именем, а не числом. Если несколько групп
имеют то же имя, то оно относится к самой левой найденной группе в
текущем поиске.

Будет сообщение об ошибке, если будет ссылка на имя не определенное  C << (? <NAME>) >>
ранее в шаблоне.

Обе формы являются эквивалентными.

B<ПРИМЕЧАНИЕ:> для того, чтобы сделать вещи проще для программистов с опытом работы
с Python или движком регексов PCRE, шаблон C<< (?P=NAME) >>
может быть использован вместо C<< \k<NAME> >>.

=item C<(?{ code })>
X<(?{})> X<regex, code in> X<regexp, code in> X<regular expression, code in>

B<ПРЕДУПРЕЖДЕНИЕ>: Эта функция расширенных регулярных выражений считается
экспериментальной и может быть изменена без предварительного уведомления. Выполняемый код 
имеет побочные эффекты, которые могут быть не одинаковыми от версии к версии
из-за эффекта будущего оптимизаций в движке регексов (regex engine). Для
осуществление этой функции был радикально пересмотрен 5.18.0 релиз
и его поведение в более ранних версиях perl было намного более бажное (с большим числом багов),
особенно в отношении разбора, лексических переменных, их действия, рекурсии и
повторного входа (to parsing, lexical vars, scoping, recursion and
reentrancy).

Это утверждение нулевой ширины выполняет любой встроенный код Perl. Оно всегда
завершается успешно, и ее возвращаемое значение устанавливается как  C<$^R>.

В буквенных шаблонах, код парсится в то же время, как
окружающий код. Во время обработки шаблона управление временно передаётся 
 анализатору perl пока не находистся закрывающая скобка.
Это похоже путь, которым индекс массива
 вытаскивает строку, например

    "abc$array[ 1 + f('[') + g()]def"

В частности, скобки не обязательно должны быть сбалансированы:

    s/abc(?{ f('{'); })/def/

Даже, если шаблон является интерполяцией и компилируется во время выполнения, литеральные
блоки кода компилируются один раз, во время компиляции perl; следующее
печатает "ABCD":

    print "D";
    my $qr = qr/(?{ BEGIN { print "A" } })/;
    my $foo = "foo";
    /$foo$qr(?{ BEGIN { print "B" } })/;
    BEGIN { print "C" }

В шаблонах, где текст кода является производным от информации времени выполнения
, а не появляется буквально в исходный коде /шаблоне/,
код компилируется в то же время, что и шаблон, и,
по соображениям безопасности, C<use re 'eval'> должен быть в области. 
Это нужно для остановки пользовательских шаблонов, содержащие фрагменты кода,
которые будут выполнены.

В ситуациях, когда вам нужно включить это с C<use re 'eval'> вы должны
также включить проверку на чужеродные примеси в коде( taint )
 Еще лучше, используйте аккуратно ограничения выполнения в рамках безопасного отсека (Safe compartment.). 
Смотрите L<perlsec> для деталей работы обоих этих механизмов.

С точки зрения анализа, лексическая область видимости переменной и замыканий (closures),

    /AAA(?{ BBB })CCC/

ведет себя примерно как

    /AAA/ && do { BBB } && /CCC/

Аналогичным образом,

    qr/AAA(?{ BBB })CCC/

ведет себя примерно как

    sub { /AAA/ && do { BBB } && /CCC/ }

В частности:

    { my $i = 1; $r = qr/(?{ print $i })/ }
    my $i = 2;
    /$r/; # prints "1"

Внутри блока C<(?{...})>, C<$_> относится к строке регулярного
выражения стоящего напротив. Вы также можете использовать C<pos()>, чтобу узнать
текущую позицию соответствия внутри этой строки.

Блок кода вводит новую область с точки зрения лексического
объявления переменных, но B<не> с точки зрения C<логального> и
аналогичного локализованного поведения. Чуть позже блоки кода в том же
шаблоне будет по-прежнему видеть значения, которые были локализованы в предыдущих блоках.
Эти накопленные локализации отменяются либо в конце
успешного поиска, или, если утверждение возвратилось (assertion is backtracked) (сравните
L<"Backtracking">). Например,

  $_ = 'a' x 8;
  m<
     (?{ $cnt = 0 })               # Инициализация $cnt.
     (
       a
       (?{
           local $cnt = $cnt + 1;  # Обновляем $cnt,
                                   # обратная ссылка безопасна (backtracking-safe).
       })
     )*
     aaaa
     (?{ $res = $cnt })            # При удачном поиске копирование в
                                   # не-локализованную локацию.
   >x;

первоначально увеличит C<$cnt> до 8; затем во время отступает, его
значение будет развернуто обратно до 4, это значение назначается C <$res>.
В конце выполнения регекса $cnt будет уменьшено обратно в свое первоначальное
значение 0.

Это утверждение может использоваться как условие в

    (?(condition)yes-pattern|no-pattern)

свиче (переключателе). Если I<не> использовать таким образом, то результат выполнения C<кода>
помещается в специальную переменную C<$^R>. Это происходит сразу же, так только
C<$^R> может быть использован с другими  C<(?{ code })> утверждениями внутри того же самого
регулярного выражения.

Присваивание С<$^R> выше правильно локализовано, так, что старое
значение C<$^R> восстанавливается, если утверждение возвратилось при поиске; сравните L <"Поиск с возвратом">.

Обратите внимание, что специальная переменная C<$^N> особенно полезна с блоками кода для записи результатов подсовпадений в переменные без необходимости
 отслеживать количество вложенных скобок. Например:

  $_ = "The brown fox jumps over the lazy dog";
  /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i;
  print "color = $color, animal = $animal\n";


=item C<(??{ code })>
X<(??{})>
X<regex, postponed> X<regexp, postponed> X<regular expression, postponed>

B<ПРЕДУПРЕЖДЕНИЕ>: Эта функция расширенных регулярных выражений считается
экспериментальной и может быть изменена без предварительного уведомления. Выполняемый код
имеет побочные эффекты и он может не выполняться одинаково от версии к версии
из-за эффекта будущих оптимизаций в регекс движке.

Это «отложенное» регулярное выражение. Оно ведет себя I<точно>
так же, как и C<(?{код}) , как описано выше, за исключением того, что
 возвращаемое значение не присваиваются C<$^R>, а рассматривается как
шаблон, компилируется, если он является строкой (или используется как есть, если это qr / / объект),
затем ищется соответствие, как если бы оно был вставлено вместо этой конструкции.

В ходе сопоставления этого вложенного шаблона, он имеет свой собственный набор
захваченных скобок (или захватов дальше), которые являются действительными во время подпоиска (промежуточного поиска), но удаляются, как только управление возвращается в основной шаблон. Например, следующий поиск,
с внутренним шаблоном захвата "B" и находящий "BB", пока внешний
шаблон захватывает "A";

    my $inner = '(.)\1';
    "ABBA" =~ /^(.)(??{ $inner })\1/;
    print $1; # prints "A";

Обратите внимание, что это означает, что нет никакого способа, чтобы внутренний шаблон ссылался на
группу захвата, определенную вне. (Сам блок кода можно использовать C<$1>,
и т.д., для ссылки на группу захвата включенного шаблона.) Таким образом, хотя

    ('a' x 100)=~/(??{'(.)' x 100})/

I<найдет> он I<не> установит $1 при выходе.

Следующий шаблон найдет группу в круглых скобках:

 $re = qr{
            \(
            (?:
               (?> [^()]+ )  # Не-парные без поиска с возвратом
             |
               (??{ $re })   # Группы с соответствующими парными скобками
            )*
            \)
         }x;

Смотрите также
L<C<(?I<PARNO>)>|/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>
для другого, более эффективного способа выполнения этой задачи.

Выполнение отложенного регулярного выражения 50 раз без получения какой-либо
входной строки приведет к фатальной ошибке. Максимальная глубина компилируется
в perl поэтому, чтобы  изменить её требуется кастомный билд(custom build).

=item C<(?I<PARNO>)> C<(?-I<PARNO>)> C<(?+I<PARNO>)> C<(?R)> C<(?0)>
X<(?PARNO)> X<(?1)> X<(?R)> X<(?0)> X<(?-1)> X<(?+1)> X<(?-PARNO)> X<(?+PARNO)>
X<regex, recursive> X<regexp, recursive> X<regular expression, recursive>
X<regex, relative recursion>

Аналогично работает  C<(??{ code })> за исключением того, что он не предполагает выполнение любого
кода или потенциальной компиляции строки возвращенного шаблона; вместо этого он представляет
часть текущего шаблона, содержащийся в указанной группе захвата
как независимый шаблон, который должен совпадать с текущей позиции.
Группы захвата, содержащиеся в шаблоне, будут иметь значение, как это определено
во внешней рекурсии.

I<PARNO> является последовательность цифр (не начинающихся с нуля), значение которого отражает
число пар группы захвата для рекурсии. C<(?R)> рекурсивно проходит по
по шаблону с самого начала. C<(?0)> -это альтернативный синтаксис для
C<(?R)>. Если I<PARNO> предшествует плюс или минус, то можно предположить,
чтобы быть относительным, с отрицательными числами указывает предыдущие группы захвата
, а знак плюс группы после. Таким образом  C<(?-1)>  относится к наиболее недавно
объявленной группе и C<(?+1)> указывает следующую объявленную группу.
Обратите внимание, что подсчет относительной рекурсии отличается от
относительных обратных ссылок, в том, что в рекурсию B<включаются> не закрытые группы.

Следующий шаблон ищет функцию foo(), которая может содержать
сбалансированные скобки в качестве аргумента.

  $re = qr{ (                   # парная группа 1 (полная функция)
              foo
              (                 # парная группа 2 (пары)
                \(
                  (             # парная группа 3 (содержимое парных скобок)
                  (?:
                   (?> [^()]+ ) # Не парные без поиска с возвратом
                  |
                   (?2)         # Рекурсия на начало 2-й парной группы
                  )*
                  )
                \)
              )
            )
          }x;

Если шаблон был использован следующим образом

    'foo(bar(baz)+baz(bop))'=~/$re/
        and print "\$1 = $1\n",
                  "\$2 = $2\n",
                  "\$3 = $3\n";

результаты должны быть следующие:

    $1 = foo(bar(baz)+baz(bop))
    $2 = (bar(baz)+baz(bop))
    $3 = bar(baz)+baz(bop)

Если оответствующая группа захвата не определена , то 
будет фатальная ошибка. Рекурсии глубже, чем 50 без добавления на вход новой 
строки приведет также к фатальной ошибке. Максимальная глубина копилируется
в perl, поэтому для его изменения его требуется сделать кастомный билд (requires a custom build).

Ниже показано, как с помощью отрицательной индексации 
облегчить внедрение рекурсивных структур внутри конструкции C<qr//>
для дальнейшего использования:

    my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
    if (/foo $parens \s+ \+ \s+ bar $parens/x) {
       # сделать что-то здесь...
    }

B<Примечание>, что этот шаблон не ведёт себя так же, как эквивалент в
PCRE или Python такой же формы. В Perl можно делать поиск с возвратом в рекурсируемой
 группе, в PCRE и Python рекурсия в группе рассматривается как атомарная.
 Кроме того модификаторы разрешаются во время компиляции, так что такие конструкции 
как (?i:(?1)) или (?:(?i)(?1)) не влияют на то, как вложенный шаблон будет
обрабатываться.

=item C<(?&NAME)>
X<(?&NAME)>

Рекурсия для именованных шаблонов. Идентичен  C<(?I<PARNO>)>  за исключением того, что
на скобки для рекурсии указывает имя. Если несколько скобок
имеют то же имя, то она рекурсивно берет самую левую.

Возникнет сообщение об ошибке, ссылка идет на имя, которое не объявлено где-то в
шаблон.

B<ПРИМЕЧАНИЕ:> для того, чтобы облегчить жизнь программистов с опытом работы
с Python или движком регексов PCRE, шаблон C<< (?P>NAME) >>
может быть использован вместо  C<< (?&NAME) >>.

=item C<(?(condition)yes-pattern|no-pattern)>
X<(?()>

=item C<(?(condition)yes-pattern)>

Условное выражение. Найдет C<yes-pattern> если C<condition> дает
значение true, в противном случае ищет C<no-pattern> . Отсутствует шаблон 
по которому ищется всегда.

C <(condition)> должно быть одним из: 
1) целое число в
скобках (которое валидно, если соответствуая пара скобок найдена);
2) поиск впереди/поиск назад/выполнение утверждения нулевой ширины; 
3) имя в угловых скобках или одинарных кавычках (который валидно, если найдена группа
с заданным именем); или 
4) Специальный символ (R) (true когда выполнение внутри рекурсии или eval). 
Дополнительно после R могут быть числа, (которые будут true, когда выполняться рекурсия
внутри соответствующей группы) или C<&NAME>, в этом случае она будет
иметь значение true только при выполнении во время рекурсии именованной группы.

Вот краткое изложение возможных предикатов:

=over 4

=item (1) (2) ...

Проверяет, если что-то пронумерованные группы захвата что-то нашли.

=item (<NAME>) ('NAME')

Проверяет, если что группа с заданным именем что-то нашла.

=item (?=...) (?!...) (?<=...) (?<!...)

Проверяет, найден ли шаблон (или не найден, для вариантов с '!').

=item (?{ CODE })

Обрабатывает возвращаемое значение блока кода как условие.

=item (R)

Проверяет, что выражение выполняется внутри рекурсии.

=item (R1) (R2) ...

Проверяет, если выражение выполняется во время n-ной
 группы захвата. Эта проверка является эквивалентом следующему регексу

  if ((caller(0))[3] eq 'subname') { ... }

Другими словами он не проверяет полный стек рекурсии.

=item (R&NAME)

Аналогично C<(R1)>, этот предикат проверяет при выполнении
непосредственно внутри левой группы с заданным именем (это та же самая
логика используемая C<(?&NAME)> для устранения неоднозначности). Он не проверяет полный
стек, но только имя внутренней активной рекурсии.

=item (DEFINE)

В этом случае, да-шаблон выполняется не напрямую и нет никаких нет-шабонов.
Аналогично в духе C<(?{0})> но более эффективно.
Подробнее смотрите ниже.

=back

For example:

    m{ ( \( )?
       [^()]+
       (?(1) \) )
     }x

найдет часть с непарными скобками, возможно, включенные в парные скобки.

Особая форма - это предикат C<(DEFINE)> , который никогда не выполняет своих
yes-шаблонов непосредственно и не разрешает no-шаблоны. Это позволяет
определяются подмаски, которые будут выполняться только механизмом рекурсии.
Таким образом, можно определить набор регулярных выражений, которые могут быть
 использованы в любом шаблоне, который вы выберете.

Рекомендуется, что для данного использования вы определяете блок DEFINE в
конце шаблона, и что вы задаете имена любым подшаблонам, определенным внутри него.

Кроме того, стоит отметить, что шаблоны определенные таким образом, вероятно, не могут
 эффективными, так как оптимизатор, их обрабатывающий не достаточно очень умный.

Вот пример, как это может быть использовано:

  /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))
   (?(DEFINE)
     (?<NAME_PAT>....)
     (?<ADRESS_PAT>....)
   )/x

Обратите внимание, что группы захвата внутри  соответствующей рекурсии не доступны
после возврата из нее, так как для этого нужен дополнительный слой из группы захвата. 
Таким образом  C<$+{NAME_PAT}> не будет определяться, хотя
C<$+{NAME}> будет.

Наконец имейте в виду, что подшаблоны созданные внутри блока DEFINE
считают абсолютное и относительное число захватов, таким образом:

    my @captures = "a" =~ /(.)                  # Первый захват
                           (?(DEFINE)
                               (?<EXAMPLE> 1 )  # Второй захват
                           )/x;
    say scalar @captures;

Будет выводить 2, не 1. Это особенно важно, если вы намерены
компилировать регулярное выражение с помощью  C<qr//
 и позднее интерполировать их в другой шаблон.

=item C<< (?>pattern) >>
X<backtrack> X<backtracking> X<atomic> X<possessive>

"Независимое" подвыражение, которой соответствует подстрока
 являющаяся I<автономным> (I<standalone>) 
C<шаблоном> , который найдется, если есть якорь на данной позиции,
 и он найдет I<ничего другого, кроме этой строки>.
Это конструкция полезна для оптимизации в противном случае были бы
 "вечные" поиски, потому что он не будет делать поиск с возвратом (см. L<"Backtracking">).
Он также может быть полезным в местах, где "захватить все можно и не
дать что-нибудь обратно" семантической желательно.

Например: C<< ^(?>a*)ab >> никогда не будет совпадать, тогда как C<< (?>a*) >>
(якорь в начале строки, как указано выше) будет соответствовать I<всем>
символам C<a> в начале строки, оставляя не C <a>для
поиска C<ab>. В противоположность этому C<a*ab> будет соответствовать тому же, что и C<a+b>,
поскольку поиск подгруппы C<a*> находится под влиянием следующей
группы C<ab>(см. L<"Backtracking">). В частности, C<a*> внутри
C<a*ab> будет соответствовать меньше символов, чем автономное C<a*>, так как
 оно делает хвостовой поиск.

C<< (?>pattern) >> не отключает поиск в созвратом всего один раз, пока не найдет. 
Еще воможен поиск с возвратом, проходящий мимо конструкции, но не
входящий в неё. Так что C<< ((?>a*)|(?>b*))ar >> будет по-прежнему соответствовать  "bar".

Эффект, аналогичный  C<< (?>pattern) >> может быть достигнут путем написания
C<(?=(pattern))\g{-1}>. Это соответствует той же подстроке, как автономная
C<a+> и следующий C <\g{-1}> ест совпавшие строки; он поэтому
делает утверждение нулевой длины в аналогичное C<< (?>...) >>.
(Разница между этих двумя конструкциями является тем, что во второй
используется группа захвата (записи), таким образом смещаются порядковые числа обратных ссылок
в остальной части регулярного выражения.)

Рассмотрим этот шаблон:

    m{ \(
          (
            [^()]+           # x+
          |
            \( [^()]* \)
          )+
       \)
     }x

Он будет эффективно соответствовать непустой группе с соответствующими скобками
до двух уровней или меньше. Однако, если нет такой группы, он
практически навсегда возьмет длинную строку. Это потому, что
так много различных способов разбить длинную строку на несколько
подстрок. Это то, что делает C<(.+)+> и C<(.+)+>  подобен
подшаблону выше шаблона. Рассмотрим, как шаблон
выше обнаруживает не нахождение C<((()aaaaaaaaaaaaaaaaaa> в несколько
секунд, но каждая дополнительная буква удваивает это время. Это
экспоненциальное повышение затрат сделает так, что ваша программа зависнет.
 Однако крошечные изменения в этот шаблоне

    m{ \(
          (
            (?> [^()]+ )        # изменим x+ выше на (?> x+ )
          |
            \( [^()]* \)
          )+
       \)
     }x

которая использует  C<< (?>...) >> находит точно,когда один выше делает (проверка
этого самостоятельно является хорошим упражнением), но заканчивается в четвертом
времени при использовании подобной строки с 1000000 C<a>s. Будьте осторожны,
однако, что, когда за этой конструкцией следует умножитель (квантификатор),
то он в настоящее время вызывает предупреждение под прагмой
C<use warnings> или ключа B<-w>, который говорит, что
C<"много раз найдены null строки в регексе"> (C<"matches null string many times in regex">).

На простых группах, таких, как шаблон C<< (?> [^()]+ ) >>, сопоставимый
эффект может быть достигнут путем негативного поиска вперед, как в C<[^()]+ (?! [^()] )>.
Это было только в 4 раза медленнее на строке с 1000000 C<a>s.

Сема́нтика (от др.-греч. σημαντικός — обозначающий) "Возьми все, что можешь и ничего не отдавать обратно"
 желательна во многих ситуациях, когда на первый взгляд простой  C<()*> выглядит как
правильное решение. Предположим, что мы анализировали текст с комментариями с разделителями
от C<#> за которыми следуют некоторые необязательные (горизонтальные) пробелы. В отличие от
его внешнего вида, C<#[ \t]*> I<Это неt>  правильное подвыражение для поиска
разделителей комментариев, потому что она может "отказаться" от некоторых пробелов если
остальная часть шаблона совпадет. Правильный ответ на это - ни один из них:

    (?>#[ \t]*)
    #[ \t]*(?![ \t])

Например чтобы захватить не-пустые комментарии в $1, следует использовать что-либо
одно из этого:

    / (?> \# [ \t]* ) (        .+ ) /x;
    /     \# [ \t]*   ( [^ \t] .* ) /x;

От того, что вы выбираете, зависит, какие из этих выражений лучше отражают
выше спецификации комментариев.

В некоторой литературе эта конструкция называется "атомарным поиском" или
"притяжательным поиском"("possessive matching").

Притяжательные умножители эквивалентны поставленному элементу, к которому они применяются
внутри одной из этих конструкций. Применяются следующие эквиваленты:

    Форма с умножителями  Форма со скобками
    ---------------     ---------------
    PAT*+               (?>PAT*)
    PAT++               (?>PAT+)
    PAT?+               (?>PAT?)
    PAT{min,max}+       (?>PAT{min,max})

=item C<(?[ ])>

See L<perlrecharclass/Расширенные классы символов в квадратных скобках>.

=back

=head2 Специальные глаголы для управления поиска с возвратом (Special Backtracking Control Verbs)

B<ПРЕДУПРЕЖДЕНИЕ:> эти шаблоны являются экспериментальными и могут быть изменены или
удалены в будущей версии Perl. Их использование в продкутивном коде следует
специально отметить, чтобы избежать проблем при обновлении.

Эти специальные шаблоны, как правило, в форме C<(*VERB:ARG)>. Иногда
аргумент ARG является необязательным; в некоторых случаях это
запрещено.

Любой шаблон, содержащий специальный глагол возврата, который позволяет аргументу
иметь специальное поведение, когда выполнен он устанавливает в текущем пакете
C<$REGERROR> и C<$REGMARK> переменные. При этом применяются следующие
правила:

В случае неудачи, переменной C<$REGERROR> будет присвоено значение ARG
глагольного шаблона, если глагол принимал участие в этом поиске. Если
 значение ARG шаблона было опущено, то C<$REGERROR> будет присвоено 
имя последнего исполненного шаблона C<(*MARK:NAME)> , или в значение TRUE, если такого не было.
Кроме того, переменная C<$REGMARK> будет установлна в FALSE.

В случае успешного поиска, переменная C<$REGERROR> будет установлна в FALSE, а
переменной C<$REGMARK> будет присвоено имя последнего
исполненного шаблона C<(*MARK:NAME)>. Смотрите объяснение для
глагола C<(*MARK:NAME)> ниже.

B<ПРИМЕЧАНИЕ:> C<$REGERROR> и С<$REGMARK> не являются магическими переменными такими, как C<$1>
и большинство других переменных, связанных с регексами. Они не являются локальными для области, ни
ReadOnly, но вместо этого они аналогичны летучим переменным пакета C<$AUTOLOAD>.
Используйте C<local> для локализации изменений в их конкретной области при необходимости.

Если шаблон не содержит специального глагола для поиска с возвратом, который позволяет
аргумент, то C<$REGERROR> и C<$REGMARK> не затрагиваются вообще.

=over 3

=item Глаголы, которые принимают аргумент

=over 4

=item C<(*PRUNE)> C<(*PRUNE:NAME)>
X<(*PRUNE)> X<(*PRUNE:NAME)>

Этот шаблон нулевой ширины чернослив с возвратом дерево в текущей точке
Когда отступили в на провал. Рассмотрим шаблон C < A (* ПОДРЕЗАТЬ) B >,
где A и B являются сложные узоры. До C достигается <(*PRUNE)> глагола,
A может отступать как необходимые для сопоставления. После того, как оно будет достигнуто, соответствующие
продолжается в B, который также может отходить в случае необходимости; Однако если Б
не совпадают, то без дальнейших возвратом займет место и шаблон
не удастся прямо в текущей начальной позиции.

This zero-width pattern prunes the backtracking tree at the current point
when backtracked into on failure. Consider the pattern C<A (*PRUNE) B>,
where A and B are complex patterns. Until the C<(*PRUNE)> verb is reached,
A may backtrack as necessary to match. Once it is reached, matching
continues in B, which may also backtrack as necessary; however, should B
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.

The following example counts all the possible matching strings in a
pattern (without actually matching any of them).

    'aaab' =~ /a+b?(?{print "$&\n"; $count++})(*FAIL)/;
    print "Count=$count\n";

which produces:

    aaab
    aaa
    aa
    a
    aab
    aa
    a
    ab
    a
    Count=9

If we add a C<(*PRUNE)> before the count like the following

    'aaab' =~ /a+b?(*PRUNE)(?{print "$&\n"; $count++})(*FAIL)/;
    print "Count=$count\n";

we prevent backtracking and find the count of the longest matching string
at each matching starting point like so:

    aaab
    aab
    ab
    Count=3

Any number of C<(*PRUNE)> assertions may be used in a pattern.

See also C<< (?>pattern) >> and possessive quantifiers for other ways to
control backtracking. In some cases, the use of C<(*PRUNE)> can be
replaced with a C<< (?>pattern) >> with no functional difference; however,
C<(*PRUNE)> can be used to handle cases that cannot be expressed using a
C<< (?>pattern) >> alone.

=item C<(*SKIP)> C<(*SKIP:NAME)>
X<(*SKIP)>

This zero-width pattern is similar to C<(*PRUNE)>, except that on
failure it also signifies that whatever text that was matched leading up
to the C<(*SKIP)> pattern being executed cannot be part of I<any> match
of this pattern. This effectively means that the regex engine "skips" forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).

The name of the C<(*SKIP:NAME)> pattern has special significance. If a
C<(*MARK:NAME)> was encountered while matching, then it is that position
which is used as the "skip point". If no C<(*MARK)> of that name was
encountered, then the C<(*SKIP)> operator has no effect. When used
without a name the "skip point" is where the match point was when
executing the (*SKIP) pattern.

Compare the following to the examples in C<(*PRUNE)>; note the string
is twice as long:

 'aaabaaab' =~ /a+b?(*SKIP)(?{print "$&\n"; $count++})(*FAIL)/;
 print "Count=$count\n";

outputs

    aaab
    aaab
    Count=2

Once the 'aaab' at the start of the string has matched, and the C<(*SKIP)>
executed, the next starting point will be where the cursor was when the
C<(*SKIP)> was executed.

=item C<(*MARK:NAME)> C<(*:NAME)>
X<(*MARK)> X<(*MARK:NAME)> X<(*:NAME)>

This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later C<(*SKIP)> pattern will then skip
forward to that point if backtracked into on failure. Any number of
C<(*MARK)> patterns are allowed, and the NAME portion may be duplicated.

In addition to interacting with the C<(*SKIP)> pattern, C<(*MARK:NAME)>
can be used to "label" a pattern branch, so that after matching, the
program can determine which branches of the pattern were involved in the
match.

When a match is successful, the C<$REGMARK> variable will be set to the
name of the most recently executed C<(*MARK:NAME)> that was involved
in the match.

This can be used to determine which branch of a pattern was matched
without using a separate capture group for each branch, which in turn
can result in a performance improvement, as perl cannot optimize
C</(?:(x)|(y)|(z))/> as efficiently as something like
C</(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/>.

When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the C<$REGERROR>
variable will be set to the name of the most recently executed
C<(*MARK:NAME)>.

See L</(*SKIP)> for more details.

As a shortcut C<(*MARK:NAME)> can be written C<(*:NAME)>.

=item C<(*THEN)> C<(*THEN:NAME)>

This is similar to the "cut group" operator C<::> from Perl 6.  Like
C<(*PRUNE)>, this verb always matches, and when backtracked into on
failure, it causes the regex engine to try the next alternation in the
innermost enclosing group (capturing or otherwise) that has alternations.
The two branches of a C<(?(condition)yes-pattern|no-pattern)> do not
count as an alternation, as far as C<(*THEN)> is concerned.

Its name comes from the observation that this operation combined with the
alternation operator (C<|>) can be used to create what is essentially a
pattern-based if/then/else block:

  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )

Note that if this operator is used and NOT inside of an alternation then
it acts exactly like the C<(*PRUNE)> operator.

  / A (*PRUNE) B /

is the same as

  / A (*THEN) B /

but

  / ( A (*THEN) B | C ) /

is not the same as

  / ( A (*PRUNE) B | C ) /

as after matching the A but failing on the B the C<(*THEN)> verb will
backtrack and try C; but the C<(*PRUNE)> verb will simply fail.

=back

=item Verbs without an argument

=over 4

=item C<(*COMMIT)>
X<(*COMMIT)>

This is the Perl 6 "commit pattern" C<< <commit> >> or C<:::>. It's a
zero-width pattern similar to C<(*SKIP)>, except that when backtracked
into on failure it causes the match to fail outright. No further attempts
to find a valid match by advancing the start pointer will occur again.
For example,

 'aaabaaab' =~ /a+b?(*COMMIT)(?{print "$&\n"; $count++})(*FAIL)/;
 print "Count=$count\n";

outputs

    aaab
    Count=1

In other words, once the C<(*COMMIT)> has been entered, and if the pattern
does not match, the regex engine will not try any further matching on the
rest of the string.

=item C<(*FAIL)> C<(*F)>
X<(*FAIL)> X<(*F)>

This pattern matches nothing and always fails. It can be used to force the
engine to backtrack. It is equivalent to C<(?!)>, but easier to read. In
fact, C<(?!)> gets optimised into C<(*FAIL)> internally.

It is probably useful only when combined with C<(?{})> or C<(??{})>.

=item C<(*ACCEPT)>
X<(*ACCEPT)>

B<WARNING:> This feature is highly experimental. It is not recommended
for production code.

This pattern matches nothing and causes the end of successful matching at
the point at which the C<(*ACCEPT)> pattern was encountered, regardless of
whether there is actually more to match in the string. When inside of a
nested pattern, such as recursion, or in a subpattern dynamically generated
via C<(??{})>, only the innermost pattern is ended immediately.

If the C<(*ACCEPT)> is inside of capturing groups then the groups are
marked as ended at the point at which the C<(*ACCEPT)> was encountered.
For instance:

  'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;

will match, and C<$1> will be C<AB> and C<$2> will be C<B>, C<$3> will not
be set. If another branch in the inner parentheses was matched, such as in the
string 'ACDE', then the C<D> and C<E> would have to be matched as well.

=back

=back

=head2 Backtracking
X<backtrack> X<backtracking>

NOTE: This section presents an abstract approximation of regular
expression behavior.  For a more rigorous (and complicated) view of
the rules involved in selecting a match among possible alternatives,
see L<Combining RE Pieces>.

A fundamental feature of regular expression matching involves the
notion called I<backtracking>, which is currently used (when needed)
by all regular non-possessive expression quantifiers, namely C<*>, C<*?>, C<+>,
C<+?>, C<{n,m}>, and C<{n,m}?>.  Backtracking is often optimized
internally, but the general principle outlined here is valid.

For a regular expression to match, the I<entire> regular expression must
match, not just part of it.  So if the beginning of a pattern containing a
quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part--that's why it's called backtracking.

Here is an example of backtracking:  Let's say you want to find the
word following "foo" in the string "Food is on the foo table.":

    $_ = "Food is on the foo table.";
    if ( /\b(foo)\s+(\w+)/i ) {
        print "$2 follows $1.\n";
    }

When the match runs, the first part of the regular expression (C<\b(foo)>)
finds a possible match right at the beginning of the string, and loads up
$1 with "Foo".  However, as soon as the matching engine sees that there's
no whitespace following the "Foo" that it had saved in $1, it realizes its
mistake and starts over again one character after where it had the
tentative match.  This time it goes all the way until the next occurrence
of "foo". The complete regular expression matches this time, and you get
the expected output of "table follows foo."

Sometimes minimal matching can help a lot.  Imagine you'd like to match
everything between "foo" and "bar".  Initially, you write something
like this:

    $_ =  "The food is under the bar in the barn.";
    if ( /foo(.*)bar/ ) {
        print "got <$1>\n";
    }

Which perhaps unexpectedly yields:

  got <d is under the bar in the >

That's because C<.*> was greedy, so you get everything between the
I<first> "foo" and the I<last> "bar".  Here it's more effective
to use minimal matching to make sure you get the text between a "foo"
and the first "bar" thereafter.

    if ( /foo(.*?)bar/ ) { print "got <$1>\n" }
  got <d is under the >

Here's another example. Let's say you'd like to match a number at the end
of a string, and you also want to keep the preceding part of the match.
So you write this:

    $_ = "I have 2 numbers: 53147";
    if ( /(.*)(\d*)/ ) {                                # Wrong!
        print "Beginning is <$1>, number is <$2>.\n";
    }

That won't work at all, because C<.*> was greedy and gobbled up the
whole string. As C<\d*> can match on an empty string the complete
regular expression matched successfully.

    Beginning is <I have 2 numbers: 53147>, number is <>.

Here are some variants, most of which don't work:

    $_ = "I have 2 numbers: 53147";
    @pats = qw{
        (.*)(\d*)
        (.*)(\d+)
        (.*?)(\d*)
        (.*?)(\d+)
        (.*)(\d+)$
        (.*?)(\d+)$
        (.*)\b(\d+)$
        (.*\D)(\d+)$
    };

    for $pat (@pats) {
        printf "%-12s ", $pat;
        if ( /$pat/ ) {
            print "<$1> <$2>\n";
        } else {
            print "FAIL\n";
        }
    }

That will print out:

    (.*)(\d*)    <I have 2 numbers: 53147> <>
    (.*)(\d+)    <I have 2 numbers: 5314> <7>
    (.*?)(\d*)   <> <>
    (.*?)(\d+)   <I have > <2>
    (.*)(\d+)$   <I have 2 numbers: 5314> <7>
    (.*?)(\d+)$  <I have 2 numbers: > <53147>
    (.*)\b(\d+)$ <I have 2 numbers: > <53147>
    (.*\D)(\d+)$ <I have 2 numbers: > <53147>

As you see, this can be a bit tricky.  It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.

When using look-ahead assertions and negations, this can all get even
trickier.  Imagine you'd like to find a sequence of non-digits not
followed by "123".  You might try to write that as

    $_ = "ABC123";
    if ( /^\D*(?!123)/ ) {                # Wrong!
        print "Yup, no 123 in $_\n";
    }

But that isn't going to match; at least, not the way you're hoping.  It
claims that there is no 123 in the string.  Here's a clearer picture of
why that pattern matches, contrary to popular expectations:

    $x = 'ABC123';
    $y = 'ABC445';

    print "1: got $1\n" if $x =~ /^(ABC)(?!123)/;
    print "2: got $1\n" if $y =~ /^(ABC)(?!123)/;

    print "3: got $1\n" if $x =~ /^(\D*)(?!123)/;
    print "4: got $1\n" if $y =~ /^(\D*)(?!123)/;

This prints

    2: got ABC
    3: got AB
    4: got ABC

You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (C<\D*>) and so can use
backtracking, whereas test 1 will not.  What's happening is
that you've asked "Is it true that at the start of $x, following 0 or more
non-digits, you have something that's not 123?"  If the pattern matcher had
let C<\D*> expand to "ABC", this would have caused the whole pattern to
fail.

The search engine will initially match C<\D*> with "ABC".  Then it will
try to match C<(?!123)> with "123", which fails.  But because
a quantifier (C<\D*>) has been used in the regular expression, the
search engine can backtrack and retry the match differently
in the hope of matching the complete regular expression.

The pattern really, I<really> wants to succeed, so it uses the
standard pattern back-off-and-retry and lets C<\D*> expand to just "AB" this
time.  Now there's indeed something following "AB" that is not
"123".  It's "C123", which suffices.

We can deal with this by using both an assertion and a negation.
We'll say that the first part in $1 must be followed both by a digit
and by something that's not "123".  Remember that the look-aheads
are zero-width expressions--they only look, but don't consume any
of the string in their match.  So rewriting this way produces what
you'd expect; that is, case 5 will fail, but case 6 succeeds:

    print "5: got $1\n" if $x =~ /^(\D*)(?=\d)(?!123)/;
    print "6: got $1\n" if $y =~ /^(\D*)(?=\d)(?!123)/;

    6: got ABC

In other words, the two zero-width assertions next to each other work as though
they're ANDed together, just as you'd use any built-in assertions:  C</^$/>
matches only if you're at the beginning of the line AND the end of the
line simultaneously.  The deeper underlying truth is that juxtaposition in
regular expressions always means AND, except when you write an explicit OR
using the vertical bar.  C</ab/> means match "a" AND (then) match "b",
although the attempted matches are made at different positions because "a"
is not a zero-width assertion, but a one-width assertion.

B<WARNING>: Particularly complicated regular expressions can take
exponential time to solve because of the immense number of possible
ways they can use backtracking to try for a match.  For example, without
internal optimizations done by the regular expression engine, this will
take a painfully long time to run:

    'aaaaaaaaaaaa' =~ /((a{0,5}){0,5})*[c]/

And if you used C<*>'s in the internal groups instead of limiting them
to 0 through 5 matches, then it would take forever--or until you ran
out of stack space.  Moreover, these internal optimizations are not
always applicable.  For example, if you put C<{0,5}> instead of C<*>
on the external group, no current optimization is applicable, and the
match takes a long time to finish.

A powerful tool for optimizing such beasts is what is known as an
"independent group",
which does not backtrack (see L</C<< (?>pattern) >>>).  Note also that
zero-length look-ahead/look-behind assertions will not backtrack to make
the tail match, since they are in "logical" context: only
whether they match is considered relevant.  For an example
where side-effects of look-ahead I<might> have influenced the
following match, see L</C<< (?>pattern) >>>.

=head2 Version 8 Regular Expressions
X<regular expression, version 8> X<regex, version 8> X<regexp, version 8>

In case you're not familiar with the "regular" Version 8 regex
routines, here are the pattern-matching rules not described above.

Any single character matches itself, unless it is a I<metacharacter>
with a special meaning described here or above.  You can cause
characters that normally function as metacharacters to be interpreted
literally by prefixing them with a "\" (e.g., "\." matches a ".", not any
character; "\\" matches a "\"). This escape mechanism is also required
for the character used as the pattern delimiter.

A series of characters matches that series of characters in the target
string, so the pattern C<blurfl> would match "blurfl" in the target
string.

You can specify a character class, by enclosing a list of characters
in C<[]>, which will match any character from the list.  If the
first character after the "[" is "^", the class matches any character not
in the list.  Within a list, the "-" character specifies a
range, so that C<a-z> represents all characters between "a" and "z",
inclusive.  If you want either "-" or "]" itself to be a member of a
class, put it at the start of the list (possibly after a "^"), or
escape it with a backslash.  "-" is also taken literally when it is
at the end of the list, just before the closing "]".  (The
following all specify the same class of three characters: C<[-az]>,
C<[az-]>, and C<[a\-z]>.  All are different from C<[a-z]>, which
specifies a class containing twenty-six characters, even on EBCDIC-based
character sets.)  Also, if you try to use the character
classes C<\w>, C<\W>, C<\s>, C<\S>, C<\d>, or C<\D> as endpoints of
a range, the "-" is understood literally.

Note also that the whole range idea is rather unportable between
character sets--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabetics of equal case ([a-e],
[A-E]), or digits ([0-9]).  Anything else is unsafe.  If in doubt,
spell out the character sets in full.

Characters may be specified using a metacharacter syntax much like that
used in C: "\n" matches a newline, "\t" a tab, "\r" a carriage return,
"\f" a form feed, etc.  More generally, \I<nnn>, where I<nnn> is a string
of three octal digits, matches the character whose coded character set value
is I<nnn>.  Similarly, \xI<nn>, where I<nn> are hexadecimal digits,
matches the character whose ordinal is I<nn>. The expression \cI<x>
matches the character control-I<x>.  Finally, the "." metacharacter
matches any character except "\n" (unless you use C</s>).

You can specify a series of alternatives for a pattern using "|" to
separate them, so that C<fee|fie|foe> will match any of "fee", "fie",
or "foe" in the target string (as would C<f(e|i|o)e>).  The
first alternative includes everything from the last pattern delimiter
("(", "(?:", etc. or the beginning of the pattern) up to the first "|", and
the last alternative contains everything from the last "|" to the next
closing pattern delimiter.  That's why it's common practice to include
alternatives in parentheses: to minimize confusion about where they
start and end.

Alternatives are tried from left to right, so the first
alternative found for which the entire expression matches, is the one that
is chosen. This means that alternatives are not necessarily greedy. For
example: when matching C<foo|foot> against "barefoot", only the "foo"
part will match, as that is the first alternative tried, and it successfully
matches the target string. (This might not seem important, but it is
important when you are capturing matched text using parentheses.)

Also remember that "|" is interpreted as a literal within square brackets,
so if you write C<[fee|fie|foe]> you're really only matching C<[feio|]>.

Within a pattern, you may designate subpatterns for later reference
by enclosing them in parentheses, and you may refer back to the
I<n>th subpattern later in the pattern using the metacharacter
\I<n> or \gI<n>.  Subpatterns are numbered based on the left to right order
of their opening parenthesis.  A backreference matches whatever
actually matched the subpattern in the string being examined, not
the rules for that subpattern.  Therefore, C<(0|0x)\d*\s\g1\d*> will
match "0x1234 0x4321", but not "0x1234 01234", because subpattern
1 matched "0x", even though the rule C<0|0x> could potentially match
the leading 0 in the second number.

=head2 Warning on \1 Instead of $1

Some people get too used to writing things like:

    $pattern =~ s/(\W)/\\\1/g;

This is grandfathered (for \1 to \9) for the RHS of a substitute to avoid
shocking the
B<sed> addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of an C<s///> is a double-quoted string.  C<\1> in
the usual double-quoted string means a control-A.  The customary Unix
meaning of C<\1> is kludged in for C<s///>.  However, if you get into the habit
of doing that, you get yourself into trouble if you then add an C</e>
modifier.

    s/(\d+)/ \1 + 1 /eg;            # causes warning under -w

Or if you try to do

    s/(\d+)/\1000/;

You can't disambiguate that by saying C<\{1}000>, whereas you can fix it with
C<${1}000>.  The operation of interpolation should not be confused
with the operation of matching a backreference.  Certainly they mean two
different things on the I<left> side of the C<s///>.

=head2 Repeated Patterns Matching a Zero-length Substring

B<WARNING>: Difficult material (and prose) ahead.  This section needs a rewrite.

Regular expressions provide a terse and powerful programming language.  As
with most other power tools, power comes together with the ability
to wreak havoc.

A common abuse of this power stems from the ability to make infinite
loops using regular expressions, with something as innocuous as:

    'foo' =~ m{ ( o? )* }x;

The C<o?> matches at the beginning of C<'foo'>, and since the position
in the string is not moved by the match, C<o?> would match again and again
because of the C<*> quantifier.  Another common way to create a similar cycle
is with the looping modifier C<//g>:

    @matches = ( 'foo' =~ m{ o? }xg );

or

    print "match: <$&>\n" while 'foo' =~ m{ o? }xg;

or the loop implied by split().

However, long experience has shown that many programming tasks may
be significantly simplified by using repeated subexpressions that
may match zero-length substrings.  Here's a simple example being:

    @chars = split //, $string;           # // is not magic in split
    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /

Thus Perl allows such constructs, by I<forcefully breaking
the infinite loop>.  The rules for this are different for lower-level
loops given by the greedy quantifiers C<*+{}>, and for higher-level
ones like the C</g> modifier or split() operator.

The lower-level loops are I<interrupted> (that is, the loop is
broken) when Perl detects that a repeated expression matched a
zero-length substring.   Таким образом

   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;

is made equivalent to

   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;

For example, this program

   #!perl -l
   "aaaaab" =~ /
     (?:
        a                 # non-zero
        |                 # or
       (?{print "hello"}) # print hello whenever this
                          #    branch is tried
       (?=(b))            # zero-width assertion
     )*  # any number of times
    /x;
   print $&;
   print $1;

prints

   hello
   aaaaa
   b

Notice that "hello" is only printed once, as when Perl sees that the sixth
iteration of the outermost C<(?:)*> matches a zero-length string, it stops
the C<*>.

The higher-level loops preserve an additional state between iterations:
whether the last match was zero-length.  To break the loop, the following
match after a zero-length match is prohibited to have a length of zero.
This prohibition interacts with backtracking (see L<"Backtracking">),
and so the I<second best> match is chosen if the I<best> match is of
zero length.

For example:

    $_ = 'bar';
    s/\w??/<$&>/g;

results in C<< <><b><><a><><r><> >>.  At each position of the string the best
match given by non-greedy C<??> is the zero-length match, and the I<second
best> match is what is matched by C<\w>.  Thus zero-length matches
alternate with one-character-long matches.

Similarly, for repeated C<m/()/g> the second-best match is the match at the
position one notch further in the string.

The additional state of being I<matched with zero-length> is associated with
the matched string, and is reset by each assignment to pos().
Zero-length matches at the end of the previous match are ignored
during C<split>.

=head2 Combining RE Pieces

Each of the elementary pieces of regular expressions which were described
before (such as C<ab> or C<\Z>) could match at most one substring
at the given position of the input string.  However, in a typical regular
expression these elementary pieces are combined into more complicated
patterns using combining operators C<ST>, C<S|T>, C<S*> etc.
(in these examples C<S> and C<T> are regular subexpressions).

Such combinations can include alternatives, leading to a problem of choice:
if we match a regular expression C<a|ab> against C<"abc">, will it match
substring C<"a"> or C<"ab">?  One way to describe which substring is
actually matched is the concept of backtracking (see L<"Backtracking">).
However, this description is too low-level and makes you think
in terms of a particular implementation.

Another description starts with notions of "better"/"worse".  All the
substrings which may be matched by the given regular expression can be
sorted from the "best" match to the "worst" match, and it is the "best"
match which is chosen.  This substitutes the question of "what is chosen?"
by the question of "which matches are better, and which are worse?".

Again, for elementary pieces there is no such question, since at most
one match at a given position is possible.  This section describes the
notion of better/worse for combining operators.  In the description
below C<S> and C<T> are regular subexpressions.

=over 4

=item C<ST>

Consider two possible matches, C<AB> and C<A'B'>, C<A> and C<A'> are
substrings which can be matched by C<S>, C<B> and C<B'> are substrings
which can be matched by C<T>.

If C<A> is a better match for C<S> than C<A'>, C<AB> is a better
match than C<A'B'>.

If C<A> and C<A'> coincide: C<AB> is a better match than C<AB'> if
C<B> is a better match for C<T> than C<B'>.

=item C<S|T>

When C<S> can match, it is a better match than when only C<T> can match.

Ordering of two matches for C<S> is the same as for C<S>.  Similar for
two matches for C<T>.

=item C<S{REPEAT_COUNT}>

Matches as C<SSS...S> (repeated as many times as necessary).

=item C<S{min,max}>

Matches as C<S{max}|S{max-1}|...|S{min+1}|S{min}>.

=item C<S{min,max}?>

Matches as C<S{min}|S{min+1}|...|S{max-1}|S{max}>.

=item C<S?>, C<S*>, C<S+>

Same as C<S{0,1}>, C<S{0,BIG_NUMBER}>, C<S{1,BIG_NUMBER}> respectively.

=item C<S??>, C<S*?>, C<S+?>

Same as C<S{0,1}?>, C<S{0,BIG_NUMBER}?>, C<S{1,BIG_NUMBER}?> respectively.

=item C<< (?>S) >>

Matches the best match for C<S> and only that.

=item C<(?=S)>, C<(?<=S)>

Only the best match for C<S> is considered.  (This is important only if
C<S> has capturing parentheses, and backreferences are used somewhere
else in the whole regular expression.)

=item C<(?!S)>, C<(?<!S)>

For this grouping operator there is no need to describe the ordering, since
only whether or not C<S> can match is important.

=item C<(??{ EXPR })>, C<(?I<PARNO>)>

The ordering is the same as for the regular expression which is
the result of EXPR, or the pattern contained by capture group I<PARNO>.

=item C<(?(condition)yes-pattern|no-pattern)>

Recall that which of C<yes-pattern> or C<no-pattern> actually matches is
already determined.  The ordering of the matches is the same as for the
chosen subexpression.

=back

The above recipes describe the ordering of matches I<at a given position>.
One more rule is needed to understand how a match is determined for the
whole regular expression: a match at an earlier position is always better
than a match at a later position.

=head2 Creating Custom RE Engines

As of Perl 5.10.0, one can create custom regular expression engines.  This
is not for the faint of heart, as they have to plug in at the C level.  See
L<perlreapi> for more details.

As an alternative, overloaded constants (see L<overload>) provide a simple
way to extend the functionality of the RE engine, by substituting one
pattern for another.

Suppose that we want to enable a new RE escape-sequence C<\Y|> which
matches at a boundary between whitespace characters and non-whitespace
characters.  Note that C<(?=\S)(?<!\S)|(?!\S)(?<=\S)> matches exactly
at these positions, so we want to have each C<\Y|> in the place of the
more complicated version.  We can create a module C<customre> to do
this:

    package customre;
    use overload;

    sub import {
      shift;
      die "No argument to customre::import allowed" if @_;
      overload::constant 'qr' => \&convert;
    }

    sub invalid { die "/$_[0]/: invalid escape '\\$_[1]'"}

    # We must also take care of not escaping the legitimate \\Y|
    # sequence, hence the presence of '\\' in the conversion rules.
    my %rules = ( '\\' => '\\\\',
                  'Y|' => qr/(?=\S)(?<!\S)|(?!\S)(?<=\S)/ );
    sub convert {
      my $re = shift;
      $re =~ s{
                \\ ( \\ | Y . )
              }
              { $rules{$1} or invalid($re,$1) }sgex;
      return $re;
    }

Now C<use customre> enables the new escape in constant regular
expressions, i.e., those without any runtime variable interpolations.
As documented in L<overload>, this conversion will work only over
literal parts of regular expressions.  For C<\Y|$re\Y|> the variable
part of this regular expression needs to be converted explicitly
(but only if the special meaning of C<\Y|> should be enabled inside $re):

    use customre;
    $re = <>;
    chomp $re;
    $re = customre::convert $re;
    /\Y|$re\Y|/;

=head2 PCRE/Python Support

As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions
to the regex syntax. While Perl programmers are encouraged to use the
Perl-specific syntax, the following are also accepted:

=over 4

=item C<< (?PE<lt>NAMEE<gt>pattern) >>

Define a named capture group. Equivalent to C<< (?<NAME>pattern) >>.

=item C<< (?P=NAME) >>

Backreference to a named capture group. Equivalent to C<< \g{NAME} >>.

=item C<< (?P>NAME) >>

Subroutine call to a named capture group. Equivalent to C<< (?&NAME) >>.

=back

=head1 BUGS

Many regular expression constructs don't work on EBCDIC platforms.

There are a number of issues with regard to case-insensitive matching
in Unicode rules.  See C<i> under L</Modifiers> above.

This document varies from difficult to understand to completely
and utterly opaque.  The wandering prose riddled with jargon is
hard to fathom in several places.

This document needs a rewrite that separates the tutorial content
from the reference content.

=head1 SEE ALSO

L<perlrequick>.

L<perlretut>.

L<perlop/"Regexp Quote-Like Operators">.

L<perlop/"Gory details of parsing quoted constructs">.

L<perlfaq6>.

L<perlfunc/pos>.

L<perllocale>.

L<perlebcdic>.

I<Mastering Regular Expressions> by Jeffrey Friedl, published
by O'Reilly and Associates.

=head1 ПЕРЕВОДЧИКИ
 
=over
 
=item * Николай Мишин C<< <mi@ya.ru> >>
 
=back
