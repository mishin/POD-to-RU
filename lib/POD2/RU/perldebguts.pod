=encoding utf8

=head1 NAME/НАИМЕНОВАНИЕ

perldebguts - Внутренности отладки в Perl

=head1 ОПИСАНИЕ

Это не L<perldebug>, который говорит вам, как использовать
отладчик. Это руководство описывает низкоуровневые детали относительно
внутренностей отладчика, которые варьируются от трудно до невозможно
 понимаемых для тех, кто еще не работал плотно с внутренностями Perl.
Предостережение лектора.

=head1 Внутренние компоненты отладчика (Debugger Internals)

Perl имеет специальные хуки (hooks) отладки во время компиляции и во время выполнения, используемые
для создания среды отладки. Эти хуки не следует путать
с командами I<perl -Dxxx>, описанными в L<perlrun>, которые используются
 только, если специальный Perl построен (built) по инструкции в
  pod странице F<INSTALL> в дереве исходного кода Perl.
  
Например, когда вы называете встроенную в Perl  функцию C<caller>
из пакета C<DB>, аргументы, которые соответствующий стек
фрейм был вызван копируются в C<@DB::args> массива. Этот механизм
 включается, когда Perl вызывется с ключом  B<-d>.
В частности включены следующие дополнительные функции
(см. L<perlvar/$^P>):

=over 4

=item *

Perl вставляет содержимое C<$ENV{PERL5DB}> (или C<BEGIN {require
'perl5db.pl'}> если его нет) перед первой строкой вашей программы.

=item *

Каждый массив  C<@{"_<$filename"}>  держит строки $filename для
файла, скомпилированного с Perl. То же самое верно для C<выполняемых> (C<eval>) строк, 
которые содержат подпрограммы, или которых выполняются в настоящее время.
$filename для C<выполняемых> строк выглядит как C<(eval 34)>.

Значения в этом массиве магическое в числовом контексте: они сравнивают
равенство нулю только, если строка не ломается.

=item *

Каждый хэш C<%{"_<$filename"}> содержит точки останова и действия с ключом
по ее номеру. Отдельные записи (в отличие от всего хэша)
устанавливаемы. Perl заботится только о логическом значении правда (true) здесь, хотя
значения, используемые F<perl5db.pl> имеют форму
C<"$break_condition\0$action">. 

То же самое хранится для исполняемых строк, которые содержат подпрограммы, или
которые, выполняются в настоящее время. $filename для C<выполняемых> строк 
выглядит как C<(eval 34)>.

=item *

Каждый скаляр C<${"_<$filename"}> содержит C<"_<$filename">. 
Это также в случае выполнения строк, которые содержат подпрограммы, или
которые в настоящее время выполняются. $filename для C<выполняемых> строк 
выглядит как C<(eval 34)>.

=item *

После компиляции каждого C<требуемого> файла, но перед выполнением,
вызывается процедура C<DB::postponed(*{"_<$filename"})> , если существует
C<DB::postponed>.  Здесь $filename - это развернутое имя
 C<требуемого> файла, как он найдет в значениях (values) %INC.

=item *

После компиляции каждого C<подимени>, проверяется
C<$DB::postponed{subname}> , если она существует.  Если этот ключ существует, то
вызывается C<DB::postponed(subname)>, если существует процедура C<DB::postponed>.

=item *

Поддерживается хэш C<%DB::sub>, чьи ключи являются именами подпрограмм
и значения которых имеют форму C<filename:startline-endline>.
C<filename> имеет форму C<(eval 34)> для подпрограмм, определенные внутри
C<eval>.

=item *

Когда выполнение программы достигнет точки, на которой может стоять
точка останова, подпрограмма C<DB::DB()> вызывается, если любая из переменных
C<$DB::trace>, C<$DB::single>, или C<$DB::signal>имеет значение true. Эти переменные
не являются C<локализованными>. Эта функция отключена при выполнении
внутри  C<DB::DB()>, включая функции, которые вызываются из нее
Пока выражение C<< $^D & (1<<30) >>  имеет значение true.

=item *

Когда выполнение программы достигает вызова подпрограммы,  вместо этого производится вызов 
C<&DB::sub>(I<args>) с C<$DB::sub>, которая содержит
имя вызываемой подпрограммы. (Этого не случиться, если подпрограмма
была скомпилирована из C<DB> пакета.)

=back

Обратите внимание, что если  C<&DB::sub> нужны внешние данные, чтобы он работал,
то  без нее не возможен вызов подпрограммы. В качестве примера, стандартный
отладчик C<&DB::sub> зависит от переменной C<$DB::deep>
(Он определяет, сколько уровней рекурсии в глубину отладчика вы можете использовать
До обязательного перерыва). Если C<$DB::deep> не определено, вызовы подпрограммы
 невозможны, хотя существует C<&DB::sub>.

=head2 Написание собственного отладчика (Writing Your Own Debugger)

=head3 Переменные среды (Environment Variables)

Переменная среды C<PERL5DB> может использоваться для определения отладчика.
Например, минимальный «рабочий» отладчик (он фактически ничего не делает)
состоит из одной строки:

  sub DB::DB {}

Его можно легко определить следующим образом:

  $ PERL5DB="sub DB::DB {}" perl -d your-script

Можно создать еще один короткий отладчик в одну строку, несколько более полезный:

  sub DB::DB {print ++$i; scalar <STDIN>}

Этот отладчик выводит число, которое увеличивается для каждого оператора, с которым
 он сталкивается и ждет, пока вы нажмете новую строку, прежде чем перейдете к 
 следующему оператору(statement).

Следующий отладчик действительно полезен:

  {
    package DB;
    sub DB  {}
    sub sub {print ++$i, " $sub\n"; &$sub}
  }

Он печатает порядковый номер каждого вызова подпрограммы и имя
вызываемой подпрограммы. Обратите внимание, что C<&DB::sub> компилируется в
Пакет C<DB> с помощью директивы C<package>.

Когда он запускается, отладчик считывает ваш файл rc (F<./.perldb> или
F<~/.perldb> под Unix), который может устанавливать важные параметры.
(Здесь также можно определить подпрограмму (C<&afterinit>), она выполняется
после того как отладчик завершит свою инициализацию.)

После считывания файла rc отладчик считывает переменную окружения PERLDB_OPTS
 и использует ее для установки параметров отладчика. СОДЕРЖАНИЕ
Содержимое этой переменной обрабатывается так, как если бы они были аргументом
 C<o ...> команды отладчика (q.v. в L<perldebug/"Configurable Options">) (q.v. в L<perldebug/"Настраиваемые параметры">). 

=head3 Внутренние переменные отладчика (Debugger Internal Variables)

В дополнение к упомянутым выше переменным, связанным с файлом и подпрограммой,
отладчик также поддерживает различные магические внутренние переменные.

=over 4

=item *

C<@DB::dbline> является псевдонимом для C<@{"::_<current_file"}>, который
содержит строки выбранного в данный момент файла (скомпилированного Perl), либо
явно выбранный с помощью команды отладчика C<f> или неявно по потоку
исполнения.

Значения в этом массиве являются магическими в числовом контексте: они сравнивают
равенство нулю только в том случае, если строка не является хрупкой.(they compare
equal to zero only if the line is not breakable.)

=item *

C<%DB::dbline> является псевдонимом для C<%{"::_<current_file"}>, который
содержит точки останова и действия, заданные номером строки в
выбранный в данный момент файл, либо явно выбранный с помощью
команды отладчика C<f> , или неявно по потоку выполнения.

Как отмечалось ранее, отдельные записи (в отличие от всего хеша)
могут устанавливаться. Perl только заботится о булевой истине здесь, хотя
значения, используемые F<perl5db.pl> имеют вид
C<"$break_condition\0$action">.

=back

=head3 Функции настройки отладчика

Некоторые функции предусмотрены для упрощения настройки.

=over 4

=item *

См. L<perldebug/"Configurable Options"> (L<perldebug/"Настраиваемые параметры">) для описания параметров, проанализированных
C<DB::parse_options(string)>.

=item *

C<DB::dump_trace(skip[,count])> пропускает указанное количество кадров
и возвращает список, содержащий информацию о вызывающих кадрах (все
из них, если C<count> отсутствует).  Каждая запись является ссылкой на хэш
с ключами C<context> (либо C<.>, C<$>, or C<@>), C<sub> (имя подпрограммы
 или сведения о C<eval>), C<args> (C<undef>  или ссылка на
массив), C<file>, и C<line>.

=item *

C<DB::print_trace(FH, skip[, count[, short]])> печатает
отформатированную информацию о кадрах вызывающего (caller frames). Последние две функции могут быть
удобными в качестве аргументов командам  C<< < >>, C<< << >>.

=back

Обратите внимание, что любые переменные и функции, не документированные в
эти манах (или в L<perldebug>) рассматриваются только для внутреннего
использования и, как таковые, могут быть изменены без предварительного уведомления.

=head1 Примеры вывода списка кадров (Frame Listing Output Examples)

Опцию C<frame> можно использовать для управления выходом кадра
информации. Например, сравните этот вывод трейса:

 $ perl -de 42
 Дамп стека во время смерти включен за пределами проверки. (Stack dump during die enabled outside of evals.)

 Loading DB routines from perl5db.pl patch level 0.94
 Emacs support available.

 Enter h or 'h h' for help.

 main::(-e:1):   0
   DB<1> sub foo { 14 }

   DB<2> sub bar { 3 }

   DB<3> t print foo() * bar()
 main::((eval 172):3):   print foo() + bar();
 main::foo((eval 168):2):
 main::bar((eval 170):2):
 42

с этим, как только C<o>ption C<frame=2> был установлен:

   DB<4> o f=2
                frame = '2'
   DB<5> t print foo() * bar()
 3:      foo() * bar()
 entering main::foo
  2:     sub foo { 14 };
 exited main::foo
 entering main::bar
  2:     sub bar { 3 };
 exited main::bar
 42

В качестве демонстрации ниже мы приведем трудоемкий список
в результате установки переменной окружения  C<PERLDB_OPTS> на
значение C<f=n N>, и запуск I<perl -d -V> из командной строки.
Показано, что примеры, использующие различные значения C<n> дают вам почувстовать
 разницу между настройками. Хотя это может быть длинно, это не полный список, а только выдержки.
 
=over 4

=item 1

  entering main::BEGIN
   entering Config::BEGIN
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   Package lib/Config.pm.
   entering Config::TIEHASH
   entering Exporter::import
    entering Exporter::export
  entering Config::myconfig
   entering Config::FETCH
   entering Config::FETCH
   entering Config::FETCH
   entering Config::FETCH

=item 2

  entering main::BEGIN
   entering Config::BEGIN
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   exited Config::BEGIN
   Package lib/Config.pm.
   entering Config::TIEHASH
   exited Config::TIEHASH
   entering Exporter::import
    entering Exporter::export
    exited Exporter::export
   exited Exporter::import
  exited main::BEGIN
  entering Config::myconfig
   entering Config::FETCH
   exited Config::FETCH
   entering Config::FETCH
   exited Config::FETCH
   entering Config::FETCH

=item 3

  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from li
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'osname') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'osvers') from lib/Config.pm:574

=item 4

  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   out $=Config::BEGIN() from lib/Config.pm:0
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   out $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
  out $=main::BEGIN() from /dev/null:0
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from lib/Config.pm:574

=item 5

  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   out $=Config::BEGIN() from lib/Config.pm:0
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   out $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/E
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/E
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
  out $=main::BEGIN() from /dev/null:0
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from lib/Config.pm:574
   out $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from lib/Config.pm:574
   in  $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from lib/Config.pm:574
   out $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from lib/Config.pm:574

=item 6

  in  $=CODE(0x15eca4)() from /dev/null:0
   in  $=CODE(0x182528)() from lib/Config.pm:2
    Package lib/Exporter.pm.
   out $=CODE(0x182528)() from lib/Config.pm:0
   scalar context return from CODE(0x182528): undef
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:628
   out $=Config::TIEHASH('Config') from lib/Config.pm:628
   scalar context return from Config::TIEHASH:   empty hash
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/Exporter.pm:171
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/Exporter.pm:171
    scalar context return from Exporter::export: ''
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
   scalar context return from Exporter::import: ''

=back

Во всех случаях, показанных выше, отступ строки показывает дерево вызовов.
Если бит 2 C<frame> установлен, строка будет успешно напечатана при выходе из подпрограммы. 
Если бит 4 установлен,  аргументы печатаются наряду с информацией о вызывающей функции
Если бит 8 установлен, аргументы напечатаются, даже если они связаны или ссылаются. (even if they are tied or references.)
Если бит 16 установлен, то возвращаемое значение также печатается.

Когда пакет компилируется, строка, подобная этой

    Package lib/Carp.pm.

Печатается с правильным отступом.

=head1 Отладка регулярных выражений

Есть два способа включить вывод отладки для регулярных выражений.

Если ваш perl скомпилирован с помощью  C<-DDEBUGGING>, вы можете использовать флаг
B<-Dr> в командной строке.

В противном случае вы можете использовать C<use re 'debug'>, который работает и во
 время компиляции и во время выполнения. Начиная с Perl 5.9.5, эта прагма имеет лексическую 
область видимости.

=head2 Вывод лога во время компиляции (Compile-time Output)

Вывод отладки во время компиляции выглядит так:

  Compiling REx '[bc]d(ef*g)+h[ij]k$'
  size 45 Got 364 bytes for offset annotations.
  first at 1
  rarest char g at 0
  rarest char d at 0
     1: ANYOF[bc](12)
    12: EXACT <d>(14)
    14: CURLYX[0] {1,32767}(28)
    16:   OPEN1(18)
    18:     EXACT <e>(20)
    20:     STAR(23)
    21:       EXACT <f>(0)
    23:     EXACT <g>(25)
    25:   CLOSE1(27)
    27:   WHILEM[1/1](0)
    28: NOTHING(29)
    29: EXACT <h>(31)
    31: ANYOF[ij](42)
    42: EXACT <k>(44)
    44: EOL(45)
    45: END(0)
  anchored 'de' at 1 floating 'gh' at 3..2147483647 (checking floating) 
        stclass 'ANYOF[bc]' minlen 7 
  Offsets: [45]
  	1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
  	0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1] 0[0]
  	11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
  	0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]  
  Omitting $` $& $' support.

Первая строка показывает предварительно скомпилированную форму регулярного выражения. Вторая
показывает размер скомпилированной формы (в произвольных единицах, обычно
4-байтные слова) и общее количество байт, выделенных для
таблицы смещения/длины, обычно 4+C<размер>* 8 (offset/length table, usually 4+C<size>*8). Следующая строка показывает
 метку I<id> первого узла, с которым выполнилось сопоставление (первого найденного узла).

 Привязанный 'de' к 1 плавающей 'gh' в 3..2147483647 (проверка плавающей)
        Stclass 'ANYOF [bc]' minlen 7

  (anchored 'de' at 1 floating 'gh' at 3..2147483647 (checking floating) 
        stclass 'ANYOF[bc]' minlen 7) 
	
cтрока (разделенная на две строки) содержит информацию оптимизатора. 
В показанном примере оптимизатор обнаружил, что совпадение
должно содержать подстроку C<de> со смещением 1 плюс подстрока C<gh>
при некотором смещении между 3 и бесконечностью. Более того, при проверке на
эти подстроки (чтобы отказаться от невозможных совпадений быстро), Perl проверит
для подстроки C<gh> перед проверкой подстроки C<de>. 
Оптимизатор также может использовать знания о том, что начало матча (на
C<first> I<id>) с символьным классом и строка короче 7 символов не может быть найдена.

Поля, представляющие интерес, могут отображаться в этой строке:

=over 4

=item C<anchored> I<STRING> C<at> I<POS>

=item C<floating> I<STRING> C<at> I<POS1..POS2>

См. Выше.

=item C<matching floating/anchored>

Какую подстроку проверить в первую очередь.

=item C<minlen>

Минимальная длина поиска(match).

=item C<stclass> I<TYPE>

Тип первого совпадающего узла.

=item C<noscan>

Не сканируйте найденные подстроки.

=item C<isall>

Означает, что информация оптимизатора - это все, что
 содержит регулярное выражение, и, таким образом, нет необходимости вводить регулярное выражение вообще
 (does not need to enter the regex engine at all.)

=item C<GPOS>

Установите, если шаблон содержит C<\G>.

=item C<plus> 

Установите, если шаблон начинается с повторяющегося символа (как в C<x+y>).

=item C<implicit>

Установите, если шаблон начинается с C<.*>.

=item C<with eval> 

Установите, если шаблон содержит eval-группы, такие как C<(?{ code })> и
C<(??{ code })>.

=item C<якорный(ТИП)> (C<anchored(TYPE)>)

Если шаблон может соответствовать нескольким местам, с C<TYPE>
будучи C<BOL>, С<MBOL> или С<GPOS>. Смотрите таблицу ниже.

=back

Если подстрока, как известно, должна соответствует только в конце строки , то за ней нужно ставить символ
 C<$>, как в C<плавающий 'k'$> (C<floating 'k'$>).

Информация для оптимизатора используется, чтобы избежать ввода (медленного) регекс
двигателя для строк, которые не будут соответствовать определенно. Если флаг C<isall>
 задан, вызов обработчика регулярных выражений можно избежать даже когда оптимизатор
нашел соответствующее место для поиска.

Раздел про оптимизатор выше представляет собой список I<узлов> (I<nodes>) из скомпилированных
форм регекса. Каждая строка имеет формат

C<   >I<id>: I<ТИП> I<ОПЦИОНАЛЬНАЯ-ИНФОРМАЦИЯ> (I<следующий-ид>)
C<   >I<id>: I<TYPE> I<OPTIONAL-INFO> (I<next-id>)

=head2 Типы узлов (Types of Nodes)

Ниже приведены возможные типы, с кратким описанием:

=for comment
Эта таблица создается с помощью regen/regcomp.pl. Любые изменения, сделанные здесь,
будут потеряны.

=for regcomp.pl begin

 # ТИП описание-аргумента [число-аргументов] [прыжок-в-длину-длина] ОПИСАНИЕ
 # TYPE arg-description [num-args] [longjump-len] DESCRIPTION

 # Точки выхода
 # Exit points

 END                no         Конец программы.
 SUCCEED            no         Вернуться из подпрограммы, в основном. (Return from a subroutine, basically.)

 # Якоря:

 BOL                no         Найдет "" в начале строки.
 MBOL               no         То же,предполагая мультистроку.
 SBOL               no         То же,предполагая одностроку. (Same, assuming singleline.)
 EOS                no         Найдет "" в конце строки. (string)
 EOL                no         Найдет "" в конце линии. (line)
 MEOL               no         То же,предполагая мультистроку.
 SEOL               no         То же,предполагая одностроку.
 BOUND              no         Найдет "" при любом использовании границы слова
                               при родной семантике кодировки для не-utf8
 BOUNDL             no         Найдет "" в любой локальной границе слова ( Match "" at any locale word boundary)
 BOUNDU             no         Найдет "" в любой локальной границе слова
                               используя семантику Юникода
 BOUNDA             no         Найдет "" в любой локальной границе слова используя ASCII
                               семантику
 NBOUND             no         Найдет "" в любой не-границе слова используя
                               родные не-UTF кодировку (native charset semantics for non-utf8)
 NBOUNDL            no         Найдет "" в любой локальной не-границе слова
 NBOUNDU            no         Найдет "" в любой не-границе слова используя
                               семантику Юникода
 NBOUNDA            no         Найдет "" в любой не-границе слова используя
                               ASCII семантику
 GPOS               no         Совпадения, в которых остановились последние m//g.

 # [Специальные] альтернативы:

 REG_ANY            no         Соответствует любому символу (кроме символа новой строки).
 SANY               no         Соответствует любому одному символу.
 CANY               no         Соответствует любому одному байту.
 ANYOF              sv         Сопоставить символ в (или не в) этого
                               класса, только односимвольное соответствие
 ANYOF_WARN_SUPER   sv         Сопоставить символ в (или не в) этого
                               класса, кидает ворнинги (если включено) после нахождения
                               Char выше Unicode максимального юникода (max);
                               (Match character in (or not in) this
                               class, warn (if enabled) upon matching a
                               char above Unicode max;)
 ANYOF_SYNTHETIC    sv         Синтетический стартовый класс (Synthetic start class)

 POSIXD             none       Некоторым [[:class:]] под /d; 
                               ставит один флаг (the FLAGS field gives which one)
 POSIXL             none       Некоторым [[:class:]] под /l; 
                               ставит один флаг (the FLAGS field gives which one)
 POSIXU             none       Некоторым [[:class:]] под /u; 
                               ставит один флаг (the FLAGS field gives which one)
 POSIXA             none       Некоторым [[:class:]] под /a; 
                               ставит один флаг (the FLAGS field gives which one)
 NPOSIXD            none       дополнение класса POSIXD, [[:^class:]] (его отрицание)
 NPOSIXL            none       дополнение класса POSIXL, [[:^class:]]
 NPOSIXU            none       дополнение класса POSIXU, [[:^class:]]
 NPOSIXA            none       дополнение класса POSIXA, [[:^class:]]

 CLUMP              no         Находит расширенную последовательность графема кластера -
                               (специальное юникодной комбинации - примечание переводчика)
                               (Match any extended grapheme cluster sequence)

 # Альтернатива (Alternation)

 # BRANCH        Совокупность веток(branches), образующих единый выбор
 #               связанный вместе с их "следующими" указателями, так
 #               приоритет предотвращает все, что объединено в
 #               любых отдельных ветвях. "Следующий" указатель последней
 #               ВЕТКИ в моменты выбора следует за
 #               всем выбором. Это также, где в финале "далее"
 #               указатель каждой отдельной точки ветвления; каждая ветвь
 #               начинается с узлом операнда узла ВЕТКИ.
 
 #
 BRANCH             node       Найдет эту альтернативу или следующую ...(Match this alternative, or the next)

 # Обратный указатель (Back pointer)

 # BACK          Нормальные указатели "next" все неявно указывают вперед;
 #               BACK существует, чтобы сделать возможной структуру цикла.
 # not used
 BACK               no         Найдет "", "next" ptr показывает назад.

 # Literals

 EXACT              str        Соответствует этой строке (ей предшествует длина). (Match this string (preceded by length).)
 EXACTF             str        Найдет эту не-UTF-8 строку (нет
                               гарантии сложения (to be folded)) используя /id правил
                               (w/len).
 EXACTFL            str        Найдёт эту строку (нет
                               гарантии сложения) используя /il правила (w/len).
 EXACTFU            str        Найдёт эту строку (сложенный iff в UTF-8,
                               длина при складывании не изменяется, если не
                               в UTF-8) используя /iu правила (w/len).
 EXACTFA            str        Найдёт эту строку (нет
                               гарантии сложения) используя /iaa правила (w/len).
 EXACTFU_SS         str        Найдёт эту строку (сложенный iff в UTF-8,
                               длина в сложенном состоянии может измениться, даже если не
                               в UTF-8) используя /iu правила (w/len).
 EXACTFU_TRICKYFOLD str        Найдет эту свернутую(folded) строку UTF-8, используя /iu
                               правила

 # Ничего не делать

 NOTHING            no         Соответствует пустой строке.
 # Вариант выше, который ограничивает группу, тем самым останавливает оптимизацию
 TAIL               no         Соответствует пустой строке. Может прыгать сюда из-
                               за пределов (Match empty string. Can jump here from
                               outside).

 # Циклы


 # STAR,PLUS    '?', И сложные '*' и '+', реализованы как
 #               круговые BRANCH структуры с использованием BACK. Простые случаи
 #               (один символ в поиске (per match)) реализованы с помощью STAR
 #               и PLUS для скорости и минимизации рекурсивных погружений (plunges).
 #

 STAR               node       Найдет эту (простую) вещь 0 или более раз
 PLUS               node       Найдет эту (простую) вещь 1 или более раз

 CURLY              sv 2       Найдет эту (простую) вещь {n,m} раз
 CURLYN             no 2       Захватит следующую после этого простую вещь (сapture next-after-this simple thing)
 CURLYM             no 2       Захватит эту средне-сложную вещь {n,m} раз.
 CURLYX             sv 2       Найдет эту сложную вещь {n,m} раз.

 # Этот терминатор(разделитель) создает структуру цикла для 
 WHILEM             no         Делайте кудрявую обработку и смотрите, остались ли данные для поиска.
 			       (Do curly processing and see if rest matches.0

 # Связанные с буфером

 # OPEN,CLOSE,GROUPP     ...нумеруются во время компиляции.
 OPEN               num 1      Отметьте эту точку ввода как начало #n.
 CLOSE              num 1      Аналогично OPEN.

 REF                num 1      Соответствует некоторой уже найденной строке
 REFF               num 1      Найти уже найденную строку, свернутую
                               с использованием встроенной семантики кодировки для не-
                               utf8
 REFFL              num 1      Найти уже найденную строку, свернутую в
                               loc.
 REFFU              num 1      Найти уже найденную строку, свернутую
                               с использованием семантики Unicode для non-utf8
 REFFA              num 1      Найти уже найденную строку, свернутую
                               с использованием семантики Unicode для non-utf8, но
                               смешанную с ASCII, не-ASCII

 # Именованные ссылки. Код в regcomp.c предполагает, что все они после
 # пронумерованных ссылок
 NREF               no-sv 1    Найдет некоторую уже найденную строку
 NREFF              no-sv 1    Найти уже найденную строку, свернутую
                               с использованием встроенной семантики кодировки для не-
                               utf8
 NREFFL             no-sv 1    Найти уже найденную строку, свернутую в
                               loc.
 NREFFU             num 1      Найти уже найденную строку, свернутую
                               с использованием семантики Unicode для non-utf8
 NREFFA             num 1      Найти уже найденную строку, свернутую
                               с использованием семантики Unicode для non-utf8, но
                               смешанную с ASCII, не-ASCII

 IFMATCH            off 1 2    Успешно, если следующие совпадают.
 UNLESSM            off 1 2    Сбой, если следующие совпадают.
 SUSPEND            off 1 1    "Независимое" sub-RE (подрегулярное выражение).
 IFTHEN             off 1 1    Переключатель, которому должен предшествовать переключатель. (Switch, should be preceded by switcher.)
 GROUPP             num 1      Где находится группа. (Whether the group matched.)

 # Поддержка длинных RE

 LONGJMP            off 1 1    Прыгай далеко.
 BRANCHJ            off 1 1    BRANCH с длинным смещением.

 # Тяжелый рабочий (The heavy worker)

 EVAL               evl 1      Выполнить некоторый Perl-код.

 # Модификаторы

 MINMOD             no         Следующий оператор не жадный.
 LOGICAL            no         Следующий опкод должен устанавливать только флаг.

 # Это еще не используется
 RENUM              off 1 1    Группа с независимой нумерацией.

 # Связанные темы

 # Ведёт себя так же, как A|LIST|OF|WORDS. Варианты '..C' 
 # имеют встроенные данные charclass (только ascii), где 'C' хранит его
 # в составе.

 TRIE               trie 1     Найдет много EXACT(F[ALU]?)? один раз (at once).
                               flags==type
 TRIEC              trie       То же, что и TRIE, но со встроенным charclass

 AHOCORASICK        trie 1     Aho Corasick stclass. flags==type
 AHOCORASICKC       trie       То же, что и AHOCORASICK, но со встроенным charclass

 # Подпрограммы регулярных выражений (Regex Subroutines)
 GOSUB              num/ofs 2L рекурсия к родительскому arg1 на (подписанных) ofs arg2 (recurse to paren arg1 at (signed) ofs)
                               
 GOSTART            no         рекурсия к началу шаблона (recurse to start of pattern)

 # Специальные условия
 NGROUPP            no-sv 1    Соответствовала ли группа. (Whether the group matched.)
 INSUBP             num 1      Будем ли мы в конкретной рекурсии.
 DEFINEP            none 1     Никогда не выполняйте непосредственно.

 # Глаголы с отступами (Backtracking Verbs)
 ENDLIKE            none       Используется только для поля типа глагола (Used only for the type field of verbs)
 OPFAIL             none       Тоже, что и (?!)
 ACCEPT             parno 1    Принимает текущую найденную строку. (Accepts the current matched string.)


 # Глаголы с аргументами (Verbs With Arguments)
 VERB               no-sv 1    Используется только для поля типа глаголов (verbs)
 PRUNE              no-sv 1    Образец терпит неудачу в этой начальной точке, если нет возврата через этот 
                               (Pattern fails at this startpoint if no-
                               backtracking through this)
 MARKPOINT          no-sv 1    Нажмите текущее местоположение для отката путем вырезания. (Push the current location for rollback by
                               cut.)
 SKIP               no-sv 1    При отказе пропустить вперед (до отметки) перед повторной попыткой (On failure skip forward (to the mark)
                               before retrying)
 COMMIT             no-sv 1    Шаблон выходит из строя, если возврат (Pattern fails outright if backtracking
                               through this)
 CUTGROUP           no-sv 1    При сбое перейдите к следующему чередованию в группе (On failure go to the next alternation in
                               the group)

 # Контролируйте, что нужно держать в $&.
 KEEPS              no         $& начинается здесь.

 # Новые charclass(классы символов), похожие на шаблоны (New charclass like patterns)
 LNBREAK            none       создать шаблон начала строки (generic newline pattern)

 # СПЕЦИАЛЬНЫЕ РЕГУЛЯРКИ (SPECIAL  REGOPS)

# Это не совсем узел, а оптимизированный кусок "длинного" узла
#. Для упрощения отладки, мы отмечаем его, как будто это был узел
 OPTIMIZED          off        Заполнителя для сброса.

# Специальные свойства операции(opcode), которые не код(opcode) в скомпилированной программе
# никогда не будет этого типа. Таким образом, он может использоваться в качестве значения флага, что
# никакие другие операции(opcode) не видно. END используется аналогичным образом, в том, что END
# узел не может быть оптимизирован. Так что END предполагает "неоптимизируемость" "unoptimizable" и PSEUDO
# в смысле "не видел ничего, чтобы оптимизировать".
 PSEUDO             off        Pseudo код для внутреннего использования.

=for regcomp.pl end

=for unprinted-credits
Следующий раздел M-J. Dominus (mjd-perl-patch+@plover.com) 20010421

Следующим оптимизатором информация представляет собой дамп смещение/длина
стола, здесь разделены на несколько линий:

  Offsets: [45]
  	1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
  	0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1] 0[0]
  	11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
  	0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]  

Первая строка указывает на то, что таблица смещений/длин  содержит 45
записей. Каждая запись является парой чисел(integers), обозначается C<смещение[длина]> (C<offset[length]>.).
Записи нумеруются начиная с 1, поэтому запись #1 вот это C<1[4]> и
запись #12 это С<5[1]>. С<1[4]> указывает, что узел, обозначенный как C<1:>
(C<1: что-нибудь из[до н. э.]>)(the C<1: ANYOF[bc]>) начинается в позиции символа 1 в
предварительно скомпилированном виде регулярного выражения, и имеет длину 4 символа.
С<5[1]> в положении 12
указывает, что узел, обозначенный как c<12:>
(C<< 12: точные <д> >>)(the C<< 12: EXACT <d> >>) начинается на символ 5 в
предварительно скомпилированном виде регулярного выражения, и имеет длину 1 символ.
С<12[1]> в позиции 14
указывает, что узел, обозначенный как C<14:>
(C<< 14: CURLYX[0] {1,32767} >>) начинается в позиции знака 12 В
предварительно скомпилированном виде регулярного выражения, и имеет длину 1 символ - - -, что
является, оно соответствует C<+> символ в предварительно скомпилированном регулярном выражении (in the precompiled regex)

С<0[0]> элементы указывают на то, что нет соответствующего узла.

=head2 Вывод времени выполнения  (Run-time Output)

В первую очередь, когда происходит совпадение, может не быть времени на output даже
если включена отладка. Это означает, что регулярное выражение никогда не вошло
, и поэтому вся работа была сделана оптимизатором.

Если регулярное выражение было введено, то на выходе может выглядеть следующим образом:

  Matching '[bc]d(ef*g)+h[ij]k$' against 'abcdefg__gh__'
    Setting an EVAL scope, savestack=3
     2 <ab> <cdefg__gh_>    |  1: ANYOF
     3 <abc> <defg__gh_>    | 11: EXACT <d>
     4 <abcd> <efg__gh_>    | 13: CURLYX {1,32767}
     4 <abcd> <efg__gh_>    | 26:   WHILEM
				0 out of 1..32767  cc=effff31c
     4 <abcd> <efg__gh_>    | 15:     OPEN1
     4 <abcd> <efg__gh_>    | 17:     EXACT <e>
     5 <abcde> <fg__gh_>    | 19:     STAR
			     EXACT <f> can match 1 times out of 32767...
    Setting an EVAL scope, savestack=3
     6 <bcdef> <g__gh__>    | 22:       EXACT <g>
     7 <bcdefg> <__gh__>    | 24:       CLOSE1
     7 <bcdefg> <__gh__>    | 26:       WHILEM
				    1 out of 1..32767  cc=effff31c
    Setting an EVAL scope, savestack=12
     7 <bcdefg> <__gh__>    | 15:         OPEN1
     7 <bcdefg> <__gh__>    | 17:         EXACT <e>
       restoring \1 to 4(4)..7
				    failed, try continuation...
     7 <bcdefg> <__gh__>    | 27:         NOTHING
     7 <bcdefg> <__gh__>    | 28:         EXACT <h>
				    failed...
				failed...

The most significant information in the output is about the particular I<node>
of the compiled regex that is currently being tested against the target string.
The format of these lines is

C<    >I<STRING-OFFSET> <I<PRE-STRING>> <I<POST-STRING>>   |I<ID>:  I<TYPE>

The I<TYPE> info is indented with respect to the backtracking level.
Other incidental information appears interspersed within.

=head1 Debugging Perl Memory Usage

Perl is a profligate wastrel when it comes to memory use.  There
is a saying that to estimate memory usage of Perl, assume a reasonable
algorithm for memory allocation, multiply that estimate by 10, and
while you still may miss the mark, at least you won't be quite so
astonished.  This is not absolutely true, but may provide a good
grasp of what happens.

Assume that an integer cannot take less than 20 bytes of memory, a
float cannot take less than 24 bytes, a string cannot take less
than 32 bytes (all these examples assume 32-bit architectures, the
result are quite a bit worse on 64-bit architectures).  If a variable
is accessed in two of three different ways (which require an integer,
a float, or a string), the memory footprint may increase yet another
20 bytes.  A sloppy malloc(3) implementation can inflate these
numbers dramatically.

On the opposite end of the scale, a declaration like

  sub foo;

may take up to 500 bytes of memory, depending on which release of Perl
you're running.

Anecdotal estimates of source-to-compiled code bloat suggest an
eightfold increase.  This means that the compiled form of reasonable
(normally commented, properly indented etc.) code will take
about eight times more space in memory than the code took
on disk.

The B<-DL> command-line switch is obsolete since circa Perl 5.6.0
(it was available only if Perl was built with C<-DDEBUGGING>).
The switch was used to track Perl's memory allocations and possible
memory leaks.  These days the use of malloc debugging tools like
F<Purify> or F<valgrind> is suggested instead.  See also
L<perlhacktips/PERL_MEM_LOG>.

One way to find out how much memory is being used by Perl data
structures is to install the Devel::Size module from CPAN: it gives
you the minimum number of bytes required to store a particular data
structure.  Please be mindful of the difference between the size()
and total_size().

If Perl has been compiled using Perl's malloc you can analyze Perl
memory usage by setting $ENV{PERL_DEBUG_MSTATS}.

=head2 С помощью C<$ENV{PERL_DEBUG_MSTATS}>

Если ваш perl использует malloc() и был скомпилирован с
необходимые переключатели (это значение по умолчанию), то после этого он напечатает память
статистики использования после компиляции кода, когда C<< $ENV{PERL_DEBUG_MSTATS}
> 1 >>, и до окончания программы, когда C<<
$ENV{PERL_DEBUG_MSTATS} >= 1 >>.  Формат отчета похож на
следующий пример:

  $ PERL_DEBUG_MSTATS=2 perl -e "require Carp"
  Статистика выделения памяти после компиляции: (buckets 4(4)..8188(8192)
     14216 free:   130   117    28     7     9   0   2     2   1 0 0
		437    61    36     0     5
     60924 used:   125   137   161    55     7   8   6    16   2 0 1
		 74   109   304    84    20
  Total sbrk(): 77824/21:119. Odd ends: pad+heads+chain+tail: 0+636+0+2048.
  Статистика выделения памяти после выполнения:   (buckets 4(4)..8188(8192)
     30888 free:   245    78    85    13     6   2   1     3   2 0 1
		315   162    39    42    11
    175816 used:   265   176  1112   111    26  22  11    27   2 1 1
		196   178  1066   798    39
  Total sbrk(): 215040/47:145. Odd ends: pad+heads+chain+tail: 0+2192+0+6144.
  
Можно попросить такую статистику в произвольных точках при
выполнении с использованием функции mstat() вне стандарта
 модуля Devel::Peek.

Вот некоторые объяснения этого формата:

=over 4

=item C<buckets SMALLEST(APPROX)..GREATEST(APPROX)>

В Perl функция malloc() использует распределение по периодам. Каждый запрос округляется
до ближайшего размера бакета, и бакет извлекается из
пула бакетов такого размера.

В приведенной выше строке описаны пределы используемых в настоящее время бакетов.
Каждый бакет имеет два размера: объем памяти и максимальный размер
пользовательских данных, которые могут поместиться в бакет. Предположим, в приведенном выше
примере, чтобы наименьший бакет было размером 4. Самый большой бакет
имел бы полезный размер 8188, и след памяти был бы 8192.

В Perl, скопилирлованном для отладки, некоторые бакеты могут иметь отрицательное использование
размера. Это означает, что эти бакеты не могут (и не будут) использоваться.
Для больших контейнеров объем памяти может быть на одну страницу больше
чем квадрат 2(power of 2). Если это так, соответствующая сила двух
печатает в поле C<APPROX> выше.

=item Свободный/используемый (Free/Used)

1 или 2 строки чисел, которые соответствуют числу
пакетов (бакетов) каждый размер между C<НАИМЕНЬШИМ> и C<НАИБОЛЬШИМ>.  В
первой строке, размеры (следы памяти) пакетов сильны
из двух--или, возможно, на одну страницу больше.  Во второй строке, если имеется,
следы памяти пакетов находятся между следами памяти
из двух пакетов "выше".

Например, предположим, что в предыдущем примере, следы памяти(memory footprints)
были

     свободно:    8     16    32    64    128  256 512 1024 2048 4096 8192
	   4     12    24    48    80

С не-C<DEBUGGING> perl, пачки (buckets) начинающиеся с C<128> имеют
 4-байтовые накладные расходы, и, таким образом, 8192-длинная пачка может занять до
8188-байт.

=item C<Total sbrk(): SBRKed/SBRKs:CONTINUOUS>

Первые два поля дают общий объем памяти в Perl сбрк(2)Эд
(есс-сломался? :-) и количество сбрк(2)использованных. Третий номер
то, что Perl думает о продолжительном возвращении кусками. Пока
это число является положительным, malloc() будет предполагать, что такое возможно
что сбрк(2) будет обеспечивать продолженную память.

Память, выделенная с помощью внешних библиотек не учитывается.

=item C<pad: 0>

Количество sbrk(2)(linux комманда - изменить размер сегмента данных) памяти, необходимой для поддержания выравненных пачек(needed to keep buckets aligned).

=item C<heads: 2192>

Хотя память больших пачках хранится внутри пачки(bucket), для
меньших пакетов она хранится в отдельных зонах. Это поле дает
общую площадь этих участков.

=item C<chain: 0>

функции malloc() может хотеть разделить большой пакет на мелкие пакеты.
Если только часть умершего пакета осталась неразделенная, остальные
хранятся как элемент связанного списка. Это поле дает общий
размер этих блоков.

=item C<tail: 6144>

Чтобы свести к минимуму количество сбрк(2)с(sbrk(2)s) функциями malloc() запрашивает больше памяти. Это
поле дает Размер еще неиспользованной части, которая сбрк(2)Эд(sbrk(2)ed), собрана но
никогда не трогалась.

=back

=head1 СМОТРЕТЬ ТАКЖЕ

L<perldebug>,
L<perlguts>,
L<perlrun>
L<re>,
and
L<Devel::DProf>.

=head1 ПЕРЕВОДЧИКИ
 
=over
 
=item * Николай Мишин C<< <mi@ya.ru> >>
 
=back
